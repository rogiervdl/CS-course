<!DOCTYPE html>
<!-- [html-validate-disable no-trailing-whitespace] -->
<html lang="nl">

<head>
   <title>WPF layout | C# cursus</title>
   <meta charset="UTF-8">
   <link rel="stylesheet" href="styles.css">
</head>

<body class="language-cs showpro">
   <div id="mode">
      <span>n00b</span>
      <label class="switch">
         <input type="checkbox" checked>
         <span class="slider round"></span>
      </label>
      <span>pro</span>
   </div>
   <nav class="site__nav">
      <a href="01_csharpsyntax.html" class="main__thumb" title="01. C# syntax">
         <p class="thumb__title">01. C# syntax</p>
         <img class="thumb__visual" src="img/01_csharpsyntax/icon.jpg" alt="">
      </a>
      <a href="02_dotnetclasses.html" class="main__thumb" title="02. .NET classes">
         <p class="thumb__title">02. .NET classes</p>
         <img class="thumb__visual" src="img/02_dotnetclasses/icon.png" alt="">
      </a>
      <a href="03_wpfcontrols.html" class="main__thumb" title="03. WPF controls">
         <p class="thumb__title">03. WPF controls</p>
         <img class="thumb__visual" src="img/03_wpfcontrols/icon.png" alt="">
      </a>
      <a href="04_wpflayout.html" class="main__thumb pro" title="04. WPF layout">
         <p class="thumb__title">04. WPF layout</p>
         <img class="thumb__visual" src="img/04_wpflayout/icon2.png" alt="">
      </a>
      <a href="05_bestanden.html" class="main__thumb pro">
         <p class="thumb__title">05. bestanden</p>
         <img class="thumb__visual" src="img/05_bestanden/icon.png" alt="">
      </a>
      <a href="06_classes_properties.html" class="main__thumb pro">
         <p class="thumb__title">06. classes &amp; properties</p>
         <img class="thumb__visual" src="img/06_classes_properties/icon.png" alt="">
      </a>
      <a href="07_static_enum.html" class="main__thumb pro">
         <p class="thumb__title">07. static en enum</p>
         <img class="thumb__visual" src="img/07_static_enum/icon.png" alt="">
      </a>
      <a href="08_overerving.html" class="main__thumb pro">
         <p class="thumb__title">08. overerving</p>
         <img class="thumb__visual" src="img/08_overerving/icon.jpg" alt="">
      </a>
      <a href="09_oo_samenvatting.html" class="main__thumb pro active">
         <p class="thumb__title">09. OO samenvatting</p>
         <img class="thumb__visual" src="img/09_oo_samenvatting/icon.png" alt="">
      </a>
      <a href="10_sql_databanken.html" class="main__thumb pro">
         <p class="thumb__title">10. SQL databanken</p>
         <img class="thumb__visual" src="img/10_sql_databanken/icon.png" alt="">
      </a>
   </nav>
   <h1>09. OO samenvatting</h1>
   <div id="toc"></div>
   <main>

      <h2>Overzicht modifiers</h2>
      <p>
         Je kent ondertussen al heel wat modifiers voor classes en members. Een overzicht van de belangrijkste:
      </p>
      <table class="blue">
         <thead>
            <tr>
               <th scope="col">&nbsp;</th>
               <th scope="col">modifier</th>
               <th scope="col">betekenis</th>
            </tr>
         </thead>
         <tbody>
            <tr>
               <th scope="row" rowspan="4">beschikbaarheid</th>
               <td><code>public</code></td>
               <td>overal beschikbaar</td>
            </tr>
            <tr>
               <td><code>internal</code></td>
               <td>enkel beschikbaar binnen de namespace</td>
            </tr>
            <tr>
               <td><code>protected</code></td>
               <td>enkel beschikbaar binnen de class en overgeërfde classes</td>
            </tr>
            <tr>
               <td><code>private</code></td>
               <td>enkel beschikbaar binnen de class zelf</td>
            </tr>
            <tr>
               <th scope="row" rowspan="4">overerving</th>
               <td><code>abstract</code></td>
               <td>moet overschreven worden in overgeërfde klasse om gebruikt te kunnen worden</td>
            </tr>
            <tr>
               <td><code>virtual</code></td>
               <td>mag overschreven worden in overgeërfde klasse </td>
            </tr>
            <tr>
               <td><code>sealed</code></td>
               <td>kan niet meer overschreven worden in overgeërfde klasse</td>
            </tr>
            <tr>
               <td><code>override</code></td>
               <td>overschrijft een member van een hogere klasse</td>
            </tr>
            <tr>
               <th scope="row" rowspan="3">instantialisatie / <br>initialisatie</th>
               <td><code>static</code></td>
               <td>class: aanmaken objecten niet mogelijk; member: opgeroepen vanop de class</td>
            </tr>
            <tr>
               <td><code>const</code></td>
               <td>krijgt zijn definitieve waarde bij het begin van het programma</td>
            </tr>
            <tr>
               <td><code>readonly</code></td>
               <td>krijgt zijn definitieve waarde in de loop van het programma</td>
            </tr>
         </tbody>
      </table>

      <h2>Klassen</h2>
      <h3>Klasse definitie</h3>
      <p>
         Een <mark>class</mark> is een blauwdruk voor objecten; het bevat class <mark>members</mark>, i.e. <strong>variabelen</strong>, <strong>properties</strong>, <strong>constructors</strong> en <strong>methods</strong>. Schematisch voorbeeld:
      </p>
      <div class="precontainer">
         <pre><code>public class VeilingItem {
   // private variables
   private decimal minimumBod;
   private List&lt;decimal&gt; Biedingen = new List&lt;decimal&gt;();

   // public properties
   public string Naam { get; set; }
   public string Beschrijving { get; set; }
   public decimal HoogsteBod { get { return Biedingen.Max(); } } 

   // public constructors
   public VeilingItem() { }
   public VeilingItem(string vn, string an) { 
      this.Naam = vn;
      this.Beschrijving = an;
   }

   // public ToString() implementation
   public override string ToString() {
      return $"{Naam} (hoogste bod: {HoogsteBod})";
   }

   // public and private methods
   public bool VerwerkBod(decimal bod) {
      if (bod &lt; minimumBod) return false;
      Biedingen.Add(bod);
      return true;
   }
}
</code></pre>
      </div>
      <h3>Associatie (compositie &amp; aggregatie)</h3>
      <p>Bij <mark>associatie</mark> gebruik je bestaande klassen in je nieuwe klasse ("heeft een..."):</p>
      <div class="precontainer">
         <pre><code>class Room {
   public string Name { get; set; }
   public string Description { get; set; }
   public List&lt;Item&gt; Items { get; set; } = new List&lt;Item&gt;(); // aggregatie: item kan bestaan zonder room
   public List&lt;Door&gt; Doors { get; set; } = new List&lt;Door&gt;(); // compositie: door kan niet bestaan zonder room
   public string Image { get; }
}
</code></pre>
         <div class="codemarker" data-text="virtual" data-nth="2"></div>
      </div>
      <p>
         Er zijn twee soorten associaties:
      </p>
      <ul class="arrow">
         <li><em class="em">aggregatie</em>: A kan wel bestaan zonder B, b.v. Items in Rooms is een aggregatie (item kan bestaan zonder ruimte)</li>
         <li><em class="em">compositie</em>: A kan niet bestaan zonder B, b.v. Doors in Rooms is een compositie (deur kan niet bestaan zonder ruimte)</li>
      </ul>

      <h3>Properties</h3>
      <p>
         Een <mark>property</mark> is als een variabele, maar met meer controle over hoe waarden ingesteld (<em>get</em>) of gelezen (<em>set</em>) worden. Enkele variaties:
      </p>
      <div class="precontainer">
         <pre><code>class Customer {
   // automatische get/set properties
   public string FirstName { get; set; }
   public string LastName { get; set; }

   // property met enkel getter: read-only
   public string NameAndEmail { 
      get { return $"{FirstName} {LastName} &lt;{Email}&gt;"; } 
   }

   // publieke get, private set (waarde instellen kan enkel binnen de class) 
   public int ClientId { get; private set; }

   // property met validatie
   private MailAddress _email;
   public string Email { 
      get { return _email.Address; }
      set {
         try { MailAddress email = new MailAddress(value); } 
         catch (FormatException) { throw new ArgumentException($"ongeldige email"); }
      }
   }
}
</code></pre>
      </div>

      <h2>Static</h2>
      <h3>static members</h3>
      <div class="precontainer">
         <pre><code>class Account {
   // static members
   private static string rexAccount = @"^\d\d\d-\d\d\d\d\d\d\d-\d\d$";
   public static int NumCreated { get; private set; } = 0;
   public static bool IsValidNumber(string nr) {
      return Regex.Match(nr, rexAccount).Success;
   }

   // non-static members
   public decimal Balance { get; set; } = 0;
   public string Number { get; set; }
   public void Deposit(decimal amount) { 
      Balance += amount;
   }

   public Account(string number) {
      NumCreated++;
      Number = number;
   }
}
</code></pre>
         <div class="codemarker" data-text="private static string rexAccount = @&quot;^\d\d\d-\d\d\d\d\d\d\d-\d\d$&quot;" data-height="110" data-color="#7030A099"></div>
         <div class="codemarker" data-text="public decimal Balance { get; set; } = 0;" data-height="110" data-color="#2C618B99"></div>
      </div>
      <ul class="arrow">
         <li class="purple">static: opgeroepen vanop de klasse</li>
         <li class="navy">non-static: opgeroepen vanop een object</li>
      </ul>
      <p>Gebruikt in een programma:</p>
      <div class="precontainer">
         <pre><code>// create some accounts
Account acc1 = new Account("123-456789-012");
Account acc2 = new Account("234-567890-123");
Account acc3 = new Account("345-678901-234");

// static examples
string accNr = "456-789012";
Console.WriteLine($"{accNr} is {(Account.IsValidNumber(accNr) ? "valid" : "invalid")}");
Console.WriteLine($"{Account.NumCreated} accounts created");

// non-static examples
acc1.Deposit(100);
acc2.Deposit(300);
Console.WriteLine($"Account {acc1.Number} has balance {acc1.Balance}");
</code></pre>
         <div class="codemarker" data-text="Account.IsValidNumber(accNr)" data-color="#7030A099"></div>
         <div class="codemarker" data-text="Account.NumCreated" data-color="#7030A099"></div>
         <div class="codemarker" data-text="acc1.Deposit(100)" data-color="#2C618B99"></div>
         <div class="codemarker" data-text="acc2.Deposit(300)" data-color="#2C618B99"></div>
         <div class="codemarker" data-text="acc1.Number" data-color="#2C618B99"></div>
         <div class="codemarker" data-text="acc1.Balance" data-color="#2C618B99"></div>
      </div>


      <h3>static classes</h3>
      <p>
         Een <mark>static class</mark> is een klasse met <strong>alleen static members</strong>.
         Ze groeperen doorgaans functionaliteit die thematisch bij elkaar hoort, zonder echt de blauwdruk van een object voor te stellen.
         Zo zou je bijvoorbeeld functionaliteit voor het werken met HTML code kunnen onderbrengen in een statische class <code class="classcolor">MyHtmlFunctions</code>:
      </p>
      <div class="precontainer">
         <pre><code>static class MyHtmlFunctions {
   public static Regex RexHtmlTag { get; } = new Regex(@"&lt;[^&gt;]+&gt;");
   public static string[] TagsList { get; } = { "A", "ABBR", ... };
   public static List&lt;string&gt; GetLayoutErrors(string htmlCode) { ... }
   public static List&lt;string&gt; GetValidationErrors(string htmlCode) { ... }
   public static string ReplaceTags(string htmlCode, string tag1, string tag2) { ... } 
   public static string HtmlEntities(string htmlCode) { ... }
   ...
}
</code></pre>
      </div>
      <div class="precontainer">
         <pre><code>string code = "&lt;!DOCTYPE html&gt;&lt;html...";
List&lt;string&gt; errs = MyHtmlFunctions.GetValidationErrors(html);
html = MyHtmlFunctions.ReplaceTags(html, "B", "STRONG");
string safeText = MyHtmlFunctions.HtmlEntities("...unsafe text here...");
bool tagExists = MyHtmlFunctions.TagsList.Contains("BIG");
...
</code></pre>
         <div class="codemarker" data-text="MyHtmlFunctions.GetValidationErrors(" data-color="#7030A066"></div>
         <div class="codemarker" data-text="MyHtmlFunctions.ReplaceTags(" data-color="#7030A066"></div>
         <div class="codemarker" data-text="MyHtmlFunctions.HtmlEntities(" data-color="#7030A066"></div>
         <div class="codemarker" data-text="MyHtmlFunctions.TagsList" data-color="#7030A066"></div>
      </div>
      <h2>Overerving</h2>
      <h3>Afgeleide klassen</h3>
      <p>
         Bij <mark>overerving</mark> breid je een bestaande klasse uit en/of pas je het aan tot een nieuwe klasse ("is een..."). Nemen we volgende basisklasse:
      </p>
      <div class="precontainer">
         <pre><code>// basisklasse Persoon
internal class Persoon {
   public string Name { get; set; }
   public string Adres { get; set; }
}
</code></pre>
      </div>
      <p>Twee voorbeelden van afgeleide (overgeërfde) klassen:</p>
      <div class="precontainer">
         <pre><code>// overgeërfde klasse Klant; heeft de property Loon en de overgeërfde properties Naam en Adres
internal class Klant : Persoon {
   public decimal Loon { get; set; }
}
</code></pre>
         <div class="codemarker" data-text="Klant : Persoon"></div>
      </div>
      <div class="precontainer">
         <pre><code>// overgeërfde klasse Werknemer; heeft de property KlantNr en de overgeërfde properties Naam en Adres
internal class Werknemer : Persoon {
   public string KlantNr { get; set; }
}
</code></pre>
         <div class="codemarker" data-text="Werknemer : Persoon"></div>
      </div>
      <ul class="arrow">
         <li>overerving beschrijft een <strong>“is een”</strong> relatie, bv. een <code class="classcolor">Klant</code> <strong>is een</strong> <code class="classcolor">Persoon</code></li>
      </ul>

      <h3><code>is</code> en <code>as</code></h3>
      <p>
         <mark>is</mark> controleert of een object tot een subklasse behoort, <mark>as</mark> cast het naar een subklasse; samenvattend voorbeeld:
      </p>
      <div class="codecompare top">
         <div>
            <div class="precontainer">
               <pre><code>// basisklasse Persoon
internal class Persoon {
   public string Name { get; set; }
   public string Adres { get; set; }
}
</code></pre>
            </div>
            <div class="precontainer">
               <pre><code>// overgeërfde klasse Klant
internal class Klant : Persoon {
   public decimal Loon { get; set; }
}
</code></pre>
            </div>
            <div class="precontainer">
               <pre><code>// overgeërfde klasse Werknemer
internal class Werknemer : Persoon {
   public string KlantNr { get; set; }
}
</code></pre>
            </div>
         </div>
         <div class="precontainer">
            <pre><code>// maak lijst personen aan
List&lt;Persoon&gt; personen = new List&lt;Persoon&gt;();

// voeg klanten en werknemers toe
personen.Add(new Werknemer() { Name = "Amir", BadgeNr = 2387 });
personen.Add(new Klant() { Name = "Bernard", KlantNr = 466123 });
personen.Add(new Klant() { Name = "Chloë", KlantNr = 466123 });

// verloop personen en druk gegevens af
foreach (Persoon p in personen) {
   if (p is Werknemer) { // controleer of p Werknemer is
      Werknemer w = p as Werknemer; // zoja, cast naar Werknemer
      Console.WriteLine($"Werknemer met badge #{w.BadgeNr}: {w.Name}"); // nu kan je BadgeNr gebruiken
   }
   if (p is Klant) { // controleer of p Klant is
      Klant k = p as Klant; // zoja, cast naar Klant
      Console.WriteLine($"Klant met nummer #{k.KlantNr}: {k.Name}"); // nu kan je KlantNr gebruiken
   }
}
</code></pre>
            <div class="codemarker" data-text="p is Werknemer"></div>
            <div class="codemarker" data-text="p is Klant"></div>
            <div class="codemarker" data-text="p as Werknemer"></div>
            <div class="codemarker" data-text="p as Klant"></div>

         </div>
      </div>
      <h3>base</h3>
      <p>
         Het sleutelwoord <mark>base</mark> verwijst expliciet naar een member uit de superklasse:
      </p>
      <div class="precontainer">
         <pre><code>class Persoon {
   public virtual void GeefBeschrijving() {
      Console.WriteLine("ik ben een persoon");
   }
}
</code></pre>
         <div class="codemarker" data-text="public virtual void GeefBeschrijving"></div>
      </div>
      <div class="precontainer">
         <pre><code>class Klant : Persoon {
   public override void GeefBeschrijving() {
      base.GeefBeschrijving(); // voer eerst GeefBeschrijving() uit Persoon uit
      Console.WriteLine("ik ben een klant"); // voer dan deze regel uit
   }
}
</code></pre>
         <div class="codemarker" data-text="base.GeefBeschrijving()"></div>
      </div>
      <p>Met <strong>base</strong> kan je vanuit <code class="classcolor">Klant</code> de methode <code>GeefBeschrijving()</code> van de basisklasse <code class="classcolor">Persoon</code> oproepen. Gebruikt in een programma:</p>
      <div class="precontainer">
         <pre><code>Klant k = new Klant();
k.GeefBeschrijving();
</code></pre>
         <div class="codemarker" data-text="base.GeefBeschrijving()"></div>
      </div>
      <figure class="console">
         <pre>
ik ben een persoon
ik ben een klant</pre>
         <figcaption>resultaat in de console</figcaption>
      </figure>

      <h2>Constructors</h2>
      <p>
         Een <mark>constructor</mark> zegt hoe een object uit een klasse kan gecreëerd worden.
      </p>
      <h3><code>this()</code></h3>
      <p>
         Met <mark>this()</mark> kan je daarbij eerst een andere constructor uitvoeren in dezelfde klasse.
      </p>
      <div class="codecompare top">
         <div class="precontainer">
            <pre><code>Customer cust1 = new Customer();
Customer cust2 = new Customer("Johnny","Miles");
Customer cust3 = new Customer(
   "Johnny",
   "Miles",
   new DateTime(2024, 03, 22)
);
</code></pre>
         </div>
         <div class="precontainer">
            <pre><code>// default constructor
public Customer() {
   registerDate = DateTime.Now;
}

// constructor waarnaar verwezen wordt
public Customer(string fn, string ln) {
   registerDate = DateTime.Now;
   FirstName = fn;
   LastName = ln;
   Rating = (new Random()).Next(1, 6);
}

// constructor met parameters; this(fn, ln) verwijst naar de constructor hierboven
public Customer(string fn, string ln, int rt) : this(fn, ln) {
   Rating = rt;
}
</code></pre>
            <div class="codemarker" data-text="public Customer(string fn, string ln) {" data-height="130"></div>
            <div class="codemarker" data-text="this(fn, ln)" data-nth="2"></div>
         </div>
      </div>
      <h3>standaardconstructor</h3>
      <p>
         Als in een klasse geen constructor gedefinieerd is, wordt impliciet een <strong>lege parameterloze</strong> <mark>standaardconstructor</mark> toegevoegd. Beide fragmenten zijn dus equivalent:
      </p>
      <div class="codecompare top">
         <div class="precontainer">
            <pre><code>class Persoon {

}
</code></pre>
         </div>
         <div class="precontainer">
            <pre><code>class Persoon {    
   public Persoon() { }
}
</code></pre>
         </div>
      </div>
      <p>Gebruik van de lege constructor:</p>
      <pre><code>Persoon p2 = new Persoon(); // OK: impliciete lege standaardconstructor gebruikt</code></pre>
      <p>Als een klasse wél een constructor bevat, dan vervalt deze standaardconstructor:</p>
      <div class="precontainer">
         <pre><code>class Persoon {
   public string Naam { get; set; }
   public Persoon(string nm) {
      Naam = nm;
   }
}
</code></pre>
      </div>
      <pre><code>Persoon p1 = new Persoon("Bob"); // OK
Persoon p2 = new Persoon(); // FOUT: lege constructor bestaat niet
</code></pre>
      <p>
         Je kan uiteraard wel zelf een constructor zonder parameters voorzien:
      </p>
      <div class="precontainer">
         <pre><code>class Persoon {
   public string Naam { get; set; }
   public Persoon(string nm) {
      Naam = nm;
   }

   // voorzie zelf een lege constructor
   public Persoon() {
      Naam = "Onbekend";
   }
}
</code></pre>
      </div>
      <pre><code>Persoon p1 = new Persoon("Bob"); // OK
Persoon p2 = new Persoon(); // OK: lege constructor bestaat
</code></pre>

      <h3>constructors bij overerving</h3>
      <p>
         Bij overerving moet <strong>altijd eerst een basisconstructor opgeroepen worden</strong>. Dit kan handmatig met <code>base()</code>, waarna de afgeleide constructor uitgevoerd wordt:
      </p>
      <div class="codecompare top">
         <div>
            <div class="precontainer">
               <pre><code>// hoofdprogramma
Klant k1 = new Klant("Bob", "U0066540");
</code></pre>
            </div>
            <figure class="console">
               <pre>
constructor 2 van Persoon...
constructor van Klant...</pre>
               <figcaption>resultaat in de console</figcaption>
            </figure>
         </div>
         <div>
            <div class="precontainer">
               <pre><code>class Persoon {
   public string Name { get; set; }

   // lege constructor
   public Persoon() {
      Name = "onbekend";
      Console.WriteLine("constructor 1 van Persoon...");
   }

   // deze niet-lege constructor wordt eerst uitgevoerd
   public Persoon(string nm) {                          
      Name = nm; 
      Console.WriteLine("constructor 2 van Persoon...");
   }
}
</code></pre>
               <div class="codemarker" data-text="public Persoon(string nm) {                          " data-height="90" data-color="#2C618B99"></div>
            </div>
            <div class="precontainer">
               <pre><code>class Klant : Persoon {
   public string KlantNr { get; set; }

   // voer eerst base constructor van Persoon uit
   public Klant(string nm, string nr) : base(nm) { 
      // voer daarna de rest uit
      KlantNr = nr;                                 
      Console.WriteLine("constructor van Klant...");
   }
}
</code></pre>
               <div class="codemarker" data-text="base(nm)" data-color="#2C618B99"></div>
               <div class="codemarker" data-text="KlantNr = nr;                                 " data-color="#7030A099" data-height="45"></div>
            </div>
         </div>
      </div>
      <p>
         Als je <code>base()</code> weglaat, zal de basisconstructor zonder parameters uitgevoerd worden, waarna de afgeleide constructor uitgevoerd wordt:
      </p>
      <div class="codecompare top">
         <div>
            <div class="precontainer">
               <pre><code>// hoofdprogramma
Klant k1 = new Klant("Bob", "U0066540");
</code></pre>
            </div>
            <figure class="console">
               <pre>
constructor 1 van Persoon...
constructor van Klant...</pre>
               <figcaption>resultaat in de console</figcaption>
            </figure>
         </div>
         <div>
            <div class="precontainer">
               <pre><code>class Persoon {
   public string Name { get; set; }

   // deze lege constructor wordt eerst uitgevoerd
   public Persoon() {                                    
      Name = "onbekend";
      Console.WriteLine("constructor 1 van Persoon...");
   }

   // niet-lege constructor
   public Persoon(string nm) {                           
      Name = nm; 
      Console.WriteLine("constructor 2 van Persoon...");
   }
}
</code></pre>
               <div class="codemarker" data-text="public Persoon() {                                   " data-height="90" data-color="#2C618B99"></div>
            </div>
            <div class="precontainer">
               <pre><code>class Klant : Persoon {
   public string KlantNr { get; set; }

   // geen base, voer eerst lege constructor van Persoon uit
   public Klant(string nm, string nr)            { 
      // voer daarna de rest uit
      KlantNr = nr;                                 
      Console.WriteLine("constructor van Klant...");    
   }
}
</code></pre>
               <div class="codemarker" data-text=")            {" data-color="#2C618B99"></div>
               <div class="codemarker" data-text="KlantNr = nr;                                 " data-color="#7030A099" data-height="45"></div>
            </div>
         </div>
      </div>

      <p>
         Als je <code>base()</code> weglaat, en er is geen basisconstructor zonder parameters in de basisklasse, dan krijg je een &mdash; nogal cryptisch geformuleerde &mdash; foutmelding:
      </p>
      <div class="codecompare top">
         <img src="img/09_oo_samenvatting/base_error.png" alt="" class="w-500 bordered">
         <div>
            <div class="precontainer">
               <pre><code>class Persoon {
   public string Name { get; set; }
   // geen lege constructor                    



   public Persoon(string nm) {                           
      Name = nm; 
      Console.WriteLine("constructor 2 van Persoon...");
   }
}
</code></pre>
               <div class="codemarker" data-text="// geen lege constructor                    " data-height="80" data-color="#2C618B99"></div>
            </div>
            <div class="precontainer">
               <pre><code>class Klant : Persoon {
   public string KlantNr { get; set; }

   // fout: geen base, lege constructor van Persoon moet eerst worden uitgevoerd
   public Klant(string nm, string nr)            { 
      KlantNr = nr;
      Console.WriteLine("constructor van Klant...");    
   }
}
</code></pre>
               <div class="codemarker" data-text=")            {" data-color="#A5002199"></div>
            </div>
         </div>
      </div>

      <h2>Access modifiers</h2>
      <p>
         Access modifiers bepalen de zichtbaarheid van een class member (variabele, property, method...).
      </p>
      <ul>
         <li>
            <strong>public</strong>: in het hele programma bruikbaar
            <br><em>&mdash; vergelijk met een openbare Facebook post, voor iedereen zichtbaar</em>
         </li>
         <li>
            <strong>internal</strong>: enkel zichtbaar binnen de assembly (voor jullie komt dit neer op een project in Visual Studio)
            <br><em>&mdash; vergelijk met een Facebook post die enkel voor vrienden en vrienden van vrienden zichtbaar is</em>
         </li>
         <li>
            <strong>protected</strong>: enkel zichtbaar binnen de klasse en afgeleide klassen
            <br><em>&mdash; vergelijk met een Facebook post die enkel voor vrienden zichtbaar is</em>
         </li>
         <li>
            <strong>private</strong>: enkel zichtbaar binnen deze klasse
            <br><em>&mdash; vergelijk met een post die privé is, enkel voor jou zichtbaar</em>
         </li>
      </ul>
      <h3>standaard: <code>private</code></h3>
      <p>
         De standaard zichtbaarheid is altijd <mark>private</mark>, dus nergens zichtbaar buiten de klasse, zelfs niet in afgeleide klassen:
      </p>
      <div class="precontainer">
         <pre><code>class Account {
   int Deposit { get; set; } = 5000;
}
</code></pre>
      </div>
      <div class="precontainer">
         <pre><code>class SavingAccount : Account {
   public void PrintDeposit() {
      Console.WriteLine($"The current deposit is {Deposit}"); // fout in afgeleide klasse: Deposit is private
   }
}
</code></pre>
         <div class="codemarker" data-text="{Deposit}" data-color="#A5002199"></div>
      </div>
      <div class="precontainer">
         <pre><code>Account acc = new Account();
Console.WriteLine($"Account created with depost {acc.Deposit}"); // fout elders: Deposit is private
sa.PrintDeposit();
</code></pre>
         <div class="codemarker" data-text="{acc.Deposit}" data-color="#A5002199"></div>
      </div>
      <h3><code>protected</code></h3>
      <p>
         Als je de zichtbaarheid wil uitbreiden tot de klasse en alle afgeleide klassen, dan markeer je het <mark>protected</mark>:
      </p>
      <div class="precontainer">
         <pre><code>class Account {
   int Deposit { get; set; } = 5000;
}
</code></pre>
      </div>
      <div class="precontainer">
         <pre><code>class SavingAccount : Account {
   public void PrintDeposit() {
      Console.WriteLine($"The current deposit is {Deposit}"); // OK in afgeleide klasse: Deposit is protected
   }
}
</code></pre>
         <div class="codemarker" data-text="{Deposit}"></div>
      </div>
      <div class="precontainer">
         <pre><code>Account acc = new Account();
Console.WriteLine($"Account created with depost {acc.Deposit}"); // fout elders: Deposit is protected
sa.PrintDeposit();
</code></pre>
         <div class="codemarker" data-text="{acc.Deposit}" data-color="#A5002199"></div>
      </div>
      <h3><code>public</code></h3>
      <p>
         Als je de zichtbaarheid wil uitbreiden tot overal, dan markeer je het <mark>public</mark>:
      </p>
      <div class="precontainer">
         <pre><code>class Account {
   int Deposit { get; set; } = 5000;
}
</code></pre>
      </div>
      <div class="precontainer">
         <pre><code>class SavingAccount : Account {
   public void PrintDeposit() {
      Console.WriteLine($"The current deposit is {Deposit}"); // OK in afgeleide klasse: Deposit is public
   }
}
</code></pre>
         <div class="codemarker" data-text="{Deposit}"></div>
      </div>
      <div class="precontainer">
         <pre><code>Account acc = new Account();
Console.WriteLine($"Account created with depost {acc.Deposit}"); // OK elders: Deposit is public
sa.PrintDeposit();
</code></pre>
         <div class="codemarker" data-text="{acc.Deposit}"></div>
      </div>

      <h2><code>abstract</code>, <code>virtual</code>, <code>override</code>, <code>new</code>, <code>sealed</code></h2>
      <h3>abstract class</h3>
      <p>
         Een <mark>abstracte class</mark> moet <strong>overgeërfd</strong> worden om te kunnen gebruiken; het is “nog niet af”
      </p>
      <pre><code>// Meubel is abstract en kan niet rechtstreeks gebruikt worden
abstract class Meubel {
         ...
}</code></pre>
      <pre><code>// Tafel erft over van Meubel en kan wel gebruikt worden
class Tafel : Meubel {
   ...
}
</code></pre>
      <pre><code>// Stoel erft over van Meubel en kan wel gebruikt worden
class Stoel : Meubel {
   ...
}
</code></pre>
      <pre><code>Tafel tafel1 = new Tafel(); // OK
Stoel stoel1 = new Stoel(); // OK
Meubel meubel1 = new Meubel(); // FOUT: Meubel is abstract
</code></pre>
      <ul class="arrow">
         <li>voordeel: een abstracte class is misschien niet direct bruikbaar, maar kan wel <strong>al veel functionaliteit</strong> bevatten voor <strong>afgeleide klassen</strong>.</li>
      </ul>

      <h3>abstract, override</h3>
      <p>
         Een <mark>abstracte methode of property</mark> <em>moet</em> <strong>overschreven</strong> worden in afgeleide klassen met <code>override</code>.
      </p>
      <pre><code>abstract class Persoon {
   ...

   // merk op: geen body want is abstract en moet overschreven worden
   public abstract void GeefBeschrijving();
}
</code></pre>
      <pre><code>// FOUT: afgeleide klasse Werknemer moet implementatie van GeefBeschrijving() voorzien
class Werknemer : Persoon {
   ...
}
</code></pre>
      <pre><code>// OK: afgeleide klasse Klant voorziet implementatie van GeefBeschrijving()
class Klant : Persoon {
   ...   

   // markeer de overschrijvende member met override
   public override void GeefBeschrijving() { 
      Console.WriteLine("ik ben een klant");
   }
}
</code></pre>
      <p>
         Het voordeel is dat je zeker bent dat <strong>alle afgeleide klassen deze implementeren</strong>.
         <br>In volgend voorbeeld b.v. ben je zeker dat <code>GeefBeschrijving()</code> kan gebruikt worden, of de Persoon nu <code class="classcolor">Klant</code> of <code class="classcolor">Werknemer</code> is:
      </p>
      <div class="codecompare">
         <div class="precontainer">
            <pre><code>List&lt;Persoon&gt; personen = new List&lt;Persoon&gt;();
personen.Add(new Klant());
personen.Add(new Werknemer());
foreach (Persoon p in personen) {
   p.GeefBeschrijving();
}</code></pre>

            <div class="codemarker" data-text="GeefBeschrijving()"></div>
         </div>

         <figure class="console">
            <pre>
ik ben een klant
ik ben een werknemer</pre>
            <figcaption>merk op hoe voor Werknemer de standaardversie van Persoon genomen wordt</figcaption>
         </figure>

      </div>
      <ul class="arrow">
         <li>
            merk op: de interne implementatie en het resultaat van <code>GeefBeschrijving()</code> verschilt voor <code class="classcolor">Klant</code> en <code class="classcolor">Werknemer</code>, en toch is er naar de buitenwereld toe één uniforme methode
         </li>
         <li>
            dit noemt men weer <mark>polymorfisme</mark>: meerdere implementaties intern, uniform gebruik extern
         </li>
      </ul>

      <h3>abstracte methode? dan abstracte class</h3>
      <p>
         Merk op dat als een class abstracte methodes bevat, het per definitie “niet af” is en zelf dus ook abstract moet zijn:
      </p>
      <div class="codecompare top">
         <pre><code>// FOUT: klasse bevat abstracte members, dus moet zelf ook abstract zijn
class Persoon {
   ...   
   public abstract void GeefBeschrijving();
}
</code></pre>
         <pre><code>// OK, methode en class abstract
abstract class Persoon {
   ...
   public abstract void GeefBeschrijving();
}
</code></pre>
      </div>
      <h3>virtual</h3>
      <p>
         Een class member <mark>virtual</mark> declareren is als abstract, behalve dat het niet <em>moet</em> maar <em>mag</em> overschreven worden in afgeleide klassen (weer met <code>override</code>).
      </p>
      <pre><code>// basisklasse Persoon voorziet een algemene implementatie van GeefBeschrijving()
class Persoon {
   ...
   public virtual void GeefBeschrijving() { 
      Console.WriteLine("ik ben een persoon");
   }
}
</code></pre>
      <pre><code>// afgeleide klasse Werknemer voorziet geen eigen versie, geen probleem
class Werknemer : Persoon {
   ...
}
</code></pre>
      <pre><code>// afgeleide klasse Klant voorziet wel een eigen versie, ook goed
class Klant : Persoon {
   ...

   // markeer weer met override
   public override void GeefBeschrijving() { 
      Console.WriteLine("ik ben een klant");
   }
}
</code></pre>
      <p>
         Net zoals bij abstract ben je bij virtual zeker dat elke afgeleide klasse de gemarkeerde methode heeft,
         terwijl &mdash; in tegenstelling tot abstract &mdash; <strong>een standaard implementatie voorzien is</strong> voor alle afgeleide klassen.
      </p>
      <div class="codecompare">
         <div class="precontainer">
            <pre><code>List&lt;Persoon&gt; personen = new List&lt;Persoon&gt;();
personen.Add(new Persoon());
personen.Add(new Werknemer());
personen.Add(new Klant ());
foreach (Persoon p in personen) {
   p.GeefBeschrijving();
}
</code></pre>
            <div class="codemarker" data-text="GeefBeschrijving()"></div>
         </div>

         <figure class="console">
            <pre>
ik ben een persoon
ik ben een persoon
ik ben een klant</pre>
            <figcaption>merk op hoe voor Werknemer de standaardversie van Persoon genomen wordt</figcaption>
         </figure>

      </div>

      <h3>sealed</h3>
      <p>
         Als je een class member <mark>override sealed</mark> declareert, kunnen ze niet verder overschreven worden in afgeleide klassen
      </p>
      <pre><code>class Persoon {
   ...

   // methode mag overschreven worden want is marked virtual
   public virtual void GeefBeschrijving() { 
      Console.WriteLine("ik ben een persoon");
   }
}
</code></pre>
      <pre><code>class Klant : Persoon {
   ...

   // methode overschreven met override sealed
   public override sealed void GeefBeschrijving() { 
      Console.WriteLine("ik ben een klant");
   }
}
</code></pre>
      <pre><code>// OK: afgeleide klasse Klant voorziet implementatie van GeefBeschrijving()
class BevoorrechteKlant : Klant {
   ...

   // FOUT: kan niet overschreven worden want is sealed door Klant
   public override void GeefBeschrijving() { 
      Console.WriteLine("ik ben een bevoorrechte klant");
   }
}
</code></pre>
      <h3>new</h3>
      <p>Je kan in theorie ook members die niet abstract of virtual gemarkeerd zijn, toch overschrijven met <mark>new</mark>:</p>
      <div class="precontainer">
         <pre><code>class Persoon {
    ...

    // niet abstract of virtual
    public void GeefBeschrijving() { 
        Console.WriteLine("ik ben een persoon");
    }
}
</code></pre>
         <div class="codemarker" data-text="public void"></div>
      </div>
      <div class="precontainer">
         <pre><code>class Klant : Persoon {
    ...

    // toch overschreven met new
    public new void GeefBeschrijving() { 
        Console.WriteLine("ik ben een klant");
    }
}
</code></pre>
         <div class="codemarker" data-text="public new void"></div>
      </div>
      <ul class="arrow">
         <li>
            overschrijven met <code>new</code> is een <strong>slecht idee</strong> want het verbreekt de hele polymorfisme gedachte; <strong>gebruik het dus best niet</strong>
         </li>
         <li>
            de enige situatie waarin het <em>eventueel</em> bruikbaar kan zijn is als je een library gebruikt en absoluut een methode wil overschrijven met jouw eigen versie
         </li>
      </ul>
      <p>
         Eigenlijk overschrijf je geen methode, maar maak je effectief een nieuwe methode aan, zij het met dezelfde signatuur. Er is geen verband meer met de methode in de superklasse, het polymorfisme gaat verloren:
      </p>
      <div class="codecompare">
         <div>
            <div class="precontainer">
               <pre><code>List&lt;Persoon&gt; personen = new List&lt;Persoon&gt;();
personen.Add(new Persoon());
personen.Add(new Werknemer());
personen.Add(new Klant());
foreach (Persoon p in personen) {
    p.GeefBeschrijving();
}
</code></pre>
            </div>

            <figure class="console">
               <pre>
ik ben een persoon
ik ben een persoon
ik ben een persoon</pre>
            </figure>
         </div>
         <div>
            <div class="precontainer">
               <pre><code>Persoon persoon1 = new Persoon();
persoon1.GeefBeschrijving();
Klant klant1 = new Klant();
klant1.GeefBeschrijving();
Werknemer werknemer1 = new Werknemer();
werknemer1.GeefBeschrijving();
</code></pre>
            </div>
            <figure class="console">
               <pre>
ik ben een persoon
ik ben een klant
ik ben een werknemer</pre>
            </figure>
         </div>
      </div>
      <div class="tips" data-caption="☝️ GEBRUIK GEEN NEW">
         <p>
            Merk op hoe er nu effectief een verschil is tussen b.v. Klant:GeefBeschrijving() en Persoon:GeefBeschrijving(). Er is geen verband meer met de methode in de superklasse, het polymorfisme is verloren gegaan.   
         </p>
      </div>






















   </main>
   <footer>
      <img src="img/thats-all.jpg" alt="">
      <p>@2014, Rogier van der Linde</p>
   </footer>
   <a aria-label="up" id="up" href="#top"><span class="fas fa-chevron-circle-up"></span></a>
   <script src="vendor/prism.js"></script>
   <script src="js/mode.js"></script>
   <script src="js/scripts.js"></script>
   <!-- Google tag (gtag.js) -->
   <script async src="https://www.googletagmanager.com/gtag/js?id=G-Q7JWZ9HHW0"></script>
   <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() { dataLayer.push(arguments); }
      gtag('js', new Date());

      gtag('config', 'G-Q7JWZ9HHW0');
   </script>
</body>

</html>