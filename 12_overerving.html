<!DOCTYPE html>
<!-- [html-validate-disable no-trailing-whitespace] -->
<html lang="nl">

<head>
   <title>Overerving | C# cursus</title>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <link rel="stylesheet" href="common/styles.css">
   <link rel="stylesheet" href="css/styles.css">
</head>

<body class="prism-vslight language-cs showpro" id="top">
   <div id="mode">
      <span>n00b</span>
      <label class="switch">
         <input type="checkbox" checked>
         <span class="slider round"></span>
      </label>
      <span>pro</span>
   </div>
   <nav class="site__nav">
      <a href="01_variabelen.html" class="main__thumb">
         <p class="thumb__title">01. variabelen</p>
         <img class="thumb__visual" src="img/01_variabelen/icon.jpg" alt="">
      </a>
      <a href="02_selecties.html" class="main__thumb">
         <p class="thumb__title">02. selecties</p>
         <img class="thumb__visual" src="img/02_selecties/icon.jpg" alt="">
      </a>
      <a href="03_iteraties.html" class="main__thumb">
         <p class="thumb__title">03. iteraties</p>
         <img class="thumb__visual" src="img/03_iteraties/icon.jpg" alt="">
      </a>
      <a href="04_methodes.html" class="main__thumb">
         <p class="thumb__title">04. methodes</p>
         <img class="thumb__visual" src="img/04_methodes/icon.jpg" alt="">
      </a>
      <a href="05_arrays.html" class="main__thumb">
         <p class="thumb__title">05. arrays</p>
         <img class="thumb__visual" src="img/05_arrays/icon.jpg" alt="">
      </a>
      <a href="06_dotnetclasses.html" class="main__thumb">
         <p class="thumb__title">06 .NET classes</p>
         <img class="thumb__visual" src="img/06_dotnetclasses/icon.png" alt="">
      </a>
      <a href="07_wpfcontrols.html" class="main__thumb">
         <p class="thumb__title">07. WPF controls</p>
         <img class="thumb__visual" src="img/07_wpfcontrols/icon.png" alt="">
      </a>
      <a href="08_wpflayout.html" class="main__thumb pro">
         <p class="thumb__title">08. WPF layout</p>
         <img class="thumb__visual" src="img/08_wpflayout/icon2.png" alt="">
      </a>
      <a href="09_bestanden.html" class="main__thumb pro">
         <p class="thumb__title">09. bestanden</p>
         <img class="thumb__visual" src="img/09_bestanden/icon.png" alt="">
      </a>
      <a href="10_classes_properties.html" class="main__thumb pro">
         <p class="thumb__title">10. classes &amp; properties</p>
         <img class="thumb__visual" src="img/10_classes_properties/icon.png" alt="">
      </a>
      <a href="11_static_enum.html" class="main__thumb pro">
         <p class="thumb__title">11. static en enum</p>
         <img class="thumb__visual" src="img/11_static_enum/icon.png" alt="">
      </a>
      <a href="12_overerving.html" class="main__thumb pro active">
         <p class="thumb__title">12. overerving</p>
         <img class="thumb__visual" src="img/12_overerving/icon.jpg" alt="">
      </a>
      <a href="13_oo_samenvatting.html" class="main__thumb pro">
         <p class="thumb__title">13. OO samenvatting</p>
         <img class="thumb__visual" src="img/13_oo_samenvatting/icon.png" alt="">
      </a>
      <a href="14_sql_databanken.html" class="main__thumb pro">
         <p class="thumb__title">14. SQL databanken</p>
         <img class="thumb__visual" src="img/14_sql_databanken/icon.png" alt="">
      </a>
   </nav>
   <h1>12. Overerving</h1>
   <p class="othercourses"><small>Dit hoofdstuk is onderdeel van de cursus <a href="https://rogiervdl.github.io/CS-course/">C#</a>. Andere cursussen in dezelfde reeks: <a href="https://rogiervdl.github.io/HTML-course/">HTML</a>, <a href="https://rogiervdl.github.io/CSS-course/">CSS</a>, <a href="https://rogiervdl.github.io/JS-course/">Javascript</a>, <a href="https://rogiervdl.github.io/DEVENV-course/">Ontwikkelomgeving</a>.</small></p>
   <div id="toc"></div>
   <main>
      <!-- VIDEO -->
      <h2>Youtube: overerving</h2>
      <p class="small"><strong>Let op!</strong> Deze video is een al wat oudere versie van dit hoofdstuk, maar het komt nog voor het overgrote deel overeen en het zal je zeker helpen de principes te begrijpen.</p>
      <div class="flexcontainer youtubecontainer">
         <iframe class="youtube" width="600" height="378" src="https://www.youtube.com/embed/Wg-ivDaiIeU" title="YouTube video player" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
         <figure class="print">
            <a href="https://www.youtube.com/watch?v=Wg-ivDaiIeU"><img src="img/10_classes_properties/youtube-ooad-overerving.png" alt="" class="w-500"></a>
            <figcaption><a href="https://www.youtube.com/watch?v=Wg-ivDaiIeU">https://www.youtube.com/watch?v=Wg-ivDaiIeU</a>
            </figcaption>
         </figure>
         <div class="youtube_toc">
            <ul>
               <li><a href="https://www.youtube.com/watch?v=Wg-ivDaiIeU">0:00 intro</a></li>
               <li><a href="https://www.youtube.com/watch?v=Wg-ivDaiIeU?t=124">2:04 UML klassediagrammen</a></li>
               <li><a href="https://www.youtube.com/watch?v=Wg-ivDaiIeU?t=240">4:00 escape game klasse diagram</a></li>
               <li>
                  <a href="https://www.youtube.com/watch?v=Wg-ivDaiIeU&t=347">5:47 Huisdier/Kip-Kat-Konijn demo</a>
                  <ul>
                     <li><a href="https://www.youtube.com/watch?v=Wg-ivDaiIeU&t=359">5:59 Kat, Konijn en Kip klassen</a> </li>
                     <li><a href="https://www.youtube.com/watch?v=Wg-ivDaiIeU&t=607">10:07 overeenkomsten en verschillen</a></li>
                     <li><a href="https://www.youtube.com/watch?v=Wg-ivDaiIeU&t=651">10:51 KipKaNijn klasse</a></li>
                     <li><a href="https://www.youtube.com/watch?v=Wg-ivDaiIeU&t=951">15:51 Huisdier superklasse</a></li>
                     <li><a href="https://www.youtube.com/watch?v=Wg-ivDaiIeU&t=1103">18:23 overerven naar Kat, Konijn en Kip, : base()</a></li>
                     <li><a href="https://www.youtube.com/watch?v=Wg-ivDaiIeU&t=1230">20:30 virtual / override</a></li>
                     <li><a href="https://www.youtube.com/watch?v=Wg-ivDaiIeU&t=1286">21:26 gebruik in hoofdprogramma</a></li>
                     <li><a href="https://www.youtube.com/watch?v=Wg-ivDaiIeU&t=1389">23:09 abstract</a></li>
                     <li><a href="https://www.youtube.com/watch?v=Wg-ivDaiIeU&t=1466">24:26 is en as; concept polymorfisme</a></li>
                     <li><a href="https://www.youtube.com/watch?v=Wg-ivDaiIeU&t=1808">30:08 samenvatting</a></li>
                  </ul>
               </li>
               <li><a href="https://www.youtube.com/watch?v=Wg-ivDaiIeU?t=1922">32:02 klassen hiÃ«rarchie</a></li>
               <li><a href="https://www.youtube.com/watch?v=Wg-ivDaiIeU?t=1960">32:40 overzicht van alle modifiers</a>
               </li>
            </ul>
         </div>
      </div>

      <h2>UML klassediagrammen</h2>
      <h3>Visuele voorstelling</h3>
      <p>
         Een <mark>UML klassediagram</mark> is een <strong>visuele voorstelling</strong> van de klassen in je programma
         (naam klasse, variabelen, methodes en properties):
      </p>
      <img src="img/12_overerving/uml.png" alt="" class="w-900">
      <ul class="arrow">
         <li><em>opmerking: voor dit vak moet je de UML klassen <strong>enkel kunnen lezen</strong>, niet zelf opstellen (dat komt aan bod in andere vakken)</em></li>
      </ul>
      <h3>Escape room voorbeeld</h3>
      <p>
         In een escape room spel zou je bijvoorbeeld drie klassen <code class="classcolor">Room</code>, <code class="classcolor">Item</code> en <code class="classcolor">Door</code> kunnen aanmaken:
      </p>
      <img src="img/12_overerving/escape_klassen.png" alt="" class="w-800">
      <p>
         Ook een statische klasse <code class="classcolor">RandomMessageGenerator</code> voor het genereren van random
         berichten van een bepaald type <code class="classcolor">Messagetype</code> (enum) kan van pas komen:
      </p>
      <img src="img/12_overerving/escape_klassen_static.png" alt="" class="w-500">

      <h2>DRY, refactoring</h2>
      <h3>Voorbeeld: klassen <code class="classcolor">Kat</code>, <code class="classcolor">Konijn</code> en <code class="classcolor">Kip</code></h3>
      <p>We vertrekken van een klasse <code class="classcolor">Kat</code>:</p>
      <div class="codecompare top">
         <pre class="w-750" data-caption="test"><code>class Kat {
   // properties
   public string Naam { get; set; }
   public int Leeftijd { get; set; }
   public string Bio { get; set; } = "Er werd geen bio opgegeven.";

   // constructors
   public Kat() { }
   public Kat(string nm, int lf, string bio) { Naam = nm; Leeftijd = lf; Bio = bio; }

   // methodes
   public string Info() {
      return $@"Info:
- Leeftijd: {Leeftijd} jaar oud
- Bio: {Bio}
- Naam: {Naam}";
   }
   public string Spreek() {
      return Leeftijd &lt; 1 ? "miep" : "mauw";
   }
   public override string ToString() {
      return $"Dier: kat, naam: {Naam}, leeftijd: {Leeftijd}";
   }
}</code></pre>
         <img src="img/12_overerving/kat.png" alt="" class="w-300">
      </div>
      <p>Vervolgens maken we een klasse <code class="classcolor">Konijn</code> (veronderstel een bestaande klasse <code class="classcolor">Recept</code>):</p>
      <div class="codecompare top">
         <pre class="w-750"><code>class Konijn {
   // properties
   public string Naam { get; set; }
   public int Leeftijd { get; set; }
   public string Bio { get; set; } = "Er werd geen bio opgegeven.";
   public static List&lt;Recept&gt; Recepten = new List&lt;Recept&gt;();

   // constructors
   public Konijn() { }
   public Konijn(string nm, int lf, string bio) { Naam = nm; Leeftijd = lf; Bio = bio; }

   // methodes
   public string Info() {
      return $@"Info:
- Leeftijd: {Leeftijd} jaar oud
- Bio: {Bio}
- Naam: {Naam}";
   }
   public override string ToString() {
      return $"Dier: konijn, naam: {Naam}, leeftijd: {Leeftijd}";
   }
}</code></pre>
         <img src="img/12_overerving/konijn.png" alt="" class="w-300">
      </div>

      <p>En tenslotte ook een klasse <code class="classcolor">Kip</code>:</p>
      <div class="codecompare top">
         <pre class="w-750"><code>class Kip {
   // properties
   public int Leeftijd { get; set; }
   public static List&lt;Recept&gt; Recepten = new List&lt;Recept&gt;();
   public string Bio { get; set; } = "Er werd geen bio opgegeven.";

   // constructors
   public Kip() { }
   public Kip(int lft, string bio) { Leeftijd = lft; Bio = bio; }

   // methodes
   public string Info() {
      return $@"Info:
- Leeftijd: {Leeftijd} jaar oud
- Bio: {Bio}";
   }
   public string Spreek() {
      return Leeftijd &lt; 1 ? "piep" : "kot kot kedei";
   }
   public override string ToString() {
      return $"Dier: kip, leeftijd: {Leeftijd}";
   }
}</code></pre>
         <img src="img/12_overerving/kip.png" alt="" class="w-300">
      </div>
      <h3>Voorbeeldtoepassing</h3>
      <p>Ter illustratie een kleine toepassing:</p>
      <div class="codecompare top">
         <pre class="w-750 h-500"><code>class Program {
   static void Main(string[] args) {
      List&lt;Kip&gt; mijnKippen = new List&lt;Kip&gt;();
      mijnKippen.Add(new Kip() { Leeftijd = 0 });
      mijnKippen.Add(new Kip() { Leeftijd = 5 });
      mijnKippen.Add(new Kip(4, "Deze haan is erg schuw en duidelijk niet veel mensenliefde gewend."));

      List&lt;Kat&gt; mijnKatten = new List&lt;Kat&gt;();
      mijnKatten.Add(new Kat() { Leeftijd = 12, Naam = "Minou" });
      mijnKatten.Add(new Kat(1, "Ik heb groene ogen, daarom heet ik Pistache.", "Pistache"));

      List&lt;Konijn&gt; mijnKonijnen = new List&lt;Konijn&gt;();
      mijnKonijnen.Add(new Konijn() { Leeftijd = 7, Naam = "Flappie" });
      mijnKonijnen.Add(new Konijn(2, "Hoi ik ben Caramel en ongeveer 3 jaar oud, zwervend op straat gevonden met extreem lange nagels.", "Caramel"));

      // kippen
      foreach (Kip kip in mijnKippen) {
         Console.WriteLine(kip); // ToString() methode
         Console.WriteLine(kip.Info());
         Console.WriteLine($"De kip zegt: â{kip.Spreek()}â");
         Console.WriteLine();
      }

      // katten
      foreach (Kat kat in mijnKatten) {
         Console.WriteLine(kat); // ToString() methode
         Console.WriteLine(kat.Info());
         Console.WriteLine($"{kat.Naam} zegt: â{kat.Spreek()}â");
         Console.WriteLine();
      }

      // konijnen
      foreach (Konijn konijn in mijnKonijnen) {
         Console.WriteLine(konijn); // ToString() methode
         Console.WriteLine(konijn.Info());
         // geen Spreek(); konijnen spreken niet
         Console.WriteLine();
      }
      Console.ReadKey();
   }
}
</code></pre>
      <figure class="console h-500">
         <pre>
Dier: kip, leeftijd: 0
Info:
- Leeftijd: 0 jaar oud
- Bio: Er werd geen bio opgegeven.
De kip zegt: "piep"

Dier: kip, leeftijd: 5
Info:
- Leeftijd: 5 jaar oud
- Bio: Er werd geen bio opgegeven.
De kip zegt: "kot kot kedei"

Dier: kip, leeftijd: 4
Info:
- Leeftijd: 4 jaar oud
- Bio: Deze haan is erg schuw en duidelijk niet veel mensenliefde gewend.
De kip zegt: "kot kot kedei"

Dier: kat, naam: Minou, leeftijd: 12
Info:
- Leeftijd: 12 jaar oud
- Bio: Er werd geen bio opgegeven.
- Naam: Minou
Minou zegt: "mauw"

Dier: kat, naam: Pistache, leeftijd: 1
Info:
- Leeftijd: 1 jaar oud
- Bio: Ik heb groene ogen, daarom heet ik Pistache.
- Naam: Pistache
Pistache zegt: "mauw"

Dier: konijn, naam: Flappie, leeftijd: 7
Info:
- Leeftijd: 7 jaar oud
- Bio: Er werd geen bio opgegeven.
- Naam: Flappie

Dier: konijn, naam: Caramel, leeftijd: 2
Info:
- Leeftijd: 2 jaar oud
- Bio: Hoi ik ben Caramel en ongeveer 3 jaar oud, zwervend op straat gevonden met extreem lange nagels.
- Naam: Caramel</pre>
         <figcaption>resultaat in de console</figcaption>
      </figure>
      </div>

      <h3>DRY principe: don't repeat yourself</h3>
      <p>Als we de drie klassen naast elkaar bekijken, zijn er nogal wat overeenkomsten: </p>
      <img src="img/12_overerving/drie_apart.png" alt="" class="w-900">
      <p><strong>Herhaling</strong> van code is <strong>altijd slecht</strong> en wijst altijd op een zwakke programma structuur:</p>
      <div class="codecompare top">
         <div>
            <ul class="wrong">
               <li>foutgevoeliger (vgl. databank redundantie)</li>
               <li>onoverzichtelijk</li>
               <li>moeilijker te onderhouden</li>
            </ul>
            <p><mark>DRY principe</mark>: <strong>D</strong>onât <strong>R</strong>epeat <strong>Y</strong>ourself. Er zijn verschillende manieren om herhaling op te lossen:</p>
            <ul class="right">
               <li>een nieuwe methode schrijven</li>
               <li>een nieuwe klasse maken</li>
               <li>gebruik maken van overerving</li>
               <li>...</li>
            </ul>
         </div>
         <img src="img/12_overerving/bart.png" alt="" class="w-400">
      </div>

      <h3>Slechte oplossing: Ã©Ã©n enkele klasse</h3>
      <p>Een (slechte) oplossing om dubbele code te vermijden is alles in Ã©Ã©n klasse <code class="classcolor">KipKaNijn</code> samenpersen:</p>
      <div class="codecompare top">
         <pre class="h-500" data-caption="KipKaNijn.cs"><code>// extra enumeratie nodig!
enum DierType { Kat, Konijn, Kip }

class KipKaNijn {
   // meer constructoren!
   public KipKaNijn() { }
   public KipKaNijn(DierType ds, int lf) {
      Diersoort = ds;
      Leeftijd = lf;
   }
   public KipKaNijn(DierType ds, int lf, string nm) : this(ds, lf) {
      Naam = nm;
   }

   // dubbelzinnige properties!
   public int Leeftijd { get; set; }
   public int Bio { get; set; }
   public string Naam { get; set; } // niet relevant voor kippen
   public static List&lt;Recept&gt; Recepten  { get; set; } = new List&lt;Recept&gt;();  // niet relevant voor katten
   public DierType Diersoort { get; set; } // extra property nodig voor soort

   // methodes worden complexer met veel switch-cases!
   public string Info() {
      string info = $@"Info:
- Leeftijd: {Leeftijd} jaar oud
- Bio: {Bio}";
      if (Diersoort == DierType.Kat || Diersoort == DierType.Konijn) {
         info += $@"
- Naam: {Naam}";
      }
      return info;
    }
    public string Spreek() {
      switch (Diersoort) {
         case DierType.Kip:
            return Leeftijd &lt; 1 ? "piep" : "kot kot kedei";
         case DierType.Kat:
            return Leeftijd &lt; 1 ? "miep" : "mauw";
         default:
            return null; // or throw Exception
        }
    }
    public override string ToString() {
      switch (Diersoort) {
         case DierType.Kip:
            return $"Dier: kip, leeftijd: {Leeftijd}";
         case DierType.Kat:
            return $"Dier: kat, naam: {Naam}, leeftijd: {Leeftijd}";
         case DierType.Konijn:
            return $"Dier: konijn, naam: {Naam}, leeftijd: {Leeftijd}";
         default:
            return null; // or throw Exception
      }
    }
}</code></pre>
      </div>
      <p>Er duiken allerlei nieuwe problemen op:</p>
      <ul class="wrong">
         <li>extra enumeratie(s) nodig</li>
         <li>meer constructoren nodig</li>
         <li>niet alle properties zijn altijd relevant voor elk subtype</li>
         <li>methodes worden complexer met b.v. extra <code>switch-case</code>'s</li>
         <li>wat stelt <code class="classcolor">KipKaNijn</code> eigenlijk voor? het past niet bij onze denkwereld</li>
      </ul>
      <p>Alles in aparte klassen is geen goed idee, alles in Ã©Ã©n klasse is geen goed idee...</p>
      <p>Wat we nodig hebben is <strong>gemeenschappelijke code in superklassen</strong>, en aparte code in afgeleide subklassen. Dit principe heet <mark>overerving</mark>.</p>

      <h2>Overerving</h2>
      <p>Bekijken we nog eens de drie aparte klassen:</p>
      <img src="img/12_overerving/drie_apart.png" alt="" class="w-900">
      <h3>Superklasse <code class="classcolor">Huisdier</code></h3>
      <p>We groeperen die gemeenschappelijke delen in een nieuwe superklasse <code class="classcolor">Huisdier</code>: </p>
      <img src="img/12_overerving/huisdier_overerving.png" alt="" class="w-900">
      <p>Implementatie van de superklasse <code class="classcolor">Huisdier</code>:</p>
      <div class="codecompare top">
         <div class="precontainer">
            <pre class="w-700" data-caption="Huisdier.cs"><code>class Huisdier {
   public int Leeftijd { get; set; }
   public string Bio { get; set; } = "Er werd geen bio opgegeven.";
   public Huisdier() { }
   public Huisdier(int lf, string bio) { Leeftijd = lf; Bio = bio; }
   public string Info() {
      return $@"Info:
- Leeftijd: {Leeftijd} jaar oud
- Bio: {Bio}";
   }
}</code></pre>
            <div class="codemarker" data-text="virtual"></div>
         </div>
         <img src="img/12_overerving/huisdier.png" alt="" class="w-300">
      </div>
      <ul class="arrow">
         <li>de basisklasse bevat alle gemeenschappelijke delen: leeftijd, bio, twee constructoren en een <code>Info()</code> implementatie</li>
         <li>we hebben ervoor gekozen geen <code>ToString()</code> implementatie te voorzien omdat deze teveel verschilt</li>
         <li>de methode <code>Info()</code> is <code>virtual</code> gemarkeerd om afgeleide klassen toe te laten dit te overschrijven</li>
      </ul>
      <h3>OvergeÃ«rfde klassen <code class="classcolor">Kat:Huisdier</code>, <code class="classcolor">Kip:Huisdier</code> en <code class="classcolor">Konijn:Huisdier</code></h3>
      <p>De implementatie van de subklasse <code class="classcolor">Kat</code>, overgeÃ«rfd van <code class="classcolor">Huisdier</code></p>
      <div class="codecompare top">
         <div class="precontainer">
            <pre class="w-700" data-caption="Kat.cs"><code>class Kat : Huisdier {
   public string Naam { get; set; }

   public Kat() { }
   public Kat(int lf, string bio, string nm) : base(lf, bio) { Naam = nm; }

   public override string Info() {
      return @$"{base.Info()}
- Naam: {Naam}";
   }
   public override string ToString() {
      return $"Dier: kat, naam: {Naam}, leeftijd: {Leeftijd}";
   }
   public string Spreek() {
      return Leeftijd &lt; 1 ? "miep" : "mauw";
   }
}
            </code></pre>
            <div class="codemarker" data-text="base(lf, bio)"></div>
            <div class="codemarker" data-text="base.Info()"></div>
            <div class="codemarker" data-text="override"></div>
         </div>
         <img src="img/12_overerving/kat_overerving.png" alt="" class="w-300">
      </div>
      <ul class="arrow">
         <li>de afgeleide klasse <code class="classcolor">Kat</code> bevat alles uit de basisklasse <code class="classcolor">Huisdier</code> aangevuld met naam, uitbreidingen van de twee constructoren, een <code>Spreek()</code> en een <code>ToString()</code> methode</li>
         <li>met <code>: base(lf, bio)</code> wordt eerst de constructor uit de basisklasse <code class="classcolor">Huisdier</code> opgeroepen</li>
         <li>met <code>override</code> geef je aan dat de methode <code>Info()</code> die uit de basisklasse <code class="classcolor">Huisdier</code> overschrijft</li>
         <li>met <code>base.Info()</code> wordt de <code>Info()</code> methode de basisklasse <code class="classcolor">Huisdier</code> opgeroepen</li>
      </ul>
      <p>De implementaties van de twee andere subklassen <code class="classcolor">Kip</code> en <code class="classcolor">Konijn</code>:</p>
      <div class="codecompare top">
         <div class="precontainer">
            <pre class="w-700" data-caption="Kip.cs"><code>class Kip : Huisdier {
   public static List&lt;Recept&gt; Recepten = new List&lt;Recept&gt;();

   public Kip() { }
   public Kip(int lf, string bio) : base(lf, bio) { }

   public override string ToString() {
      return $"Dier: kip, leeftijd: {Leeftijd}";
   }
   public string Spreek() {
      return Leeftijd &lt; 1 ? "piep" : "kot kot kedei";
   }
}
</code></pre>
            <div class="codemarker" data-text="virtual" data-nth="2"></div>
         </div>
         <img src="img/12_overerving/kip_overerving.png" alt="" class="w-300">
      </div>
      <div class="codecompare top">
         <div class="precontainer">
            <pre class="w-700" data-caption="Konijn.cs"><code>class Konijn : Huisdier {
   public string Naam { get; set; }
   public static List&lt;Recept&gt; Recepten = new List&lt;Recept&gt;();

   public Konijn() { }
   public Konijn(int lf, string bio, string nm) : base(lf, bio) { Naam = nm; }

   public override string Info() {
      return @$"{base.Info()}
- Naam: {Naam}";
   }
   public override string ToString() {
      return $"Dier: konijn, naam: {Naam}, leeftijd: {Leeftijd}";
   }
}
</code></pre>
            <div class="codemarker" data-text="virtual" data-nth="2"></div>
         </div>
         <p><img src="img/12_overerving/konijn_overerving.png" alt="" class="w-300"></p>
      </div>
      <div class="tips" data-caption="ðTOP!">
         <p>
            We hebben nu een <strong>superklasse</strong> <code class="classcolor">Huisdier</code> met alle
            <strong>gemeenschappelijke</strong> kenmerken, en drie <strong>overgeÃ«rfde</strong> klassen die
            <strong>aanvullen/aanpassen</strong> waar nodig.
         </p>
      </div>

      <h2>Abstract</h2>
      <h3>Abstracte klassen</h3>
      <p>
         Je zou kunnen argumenteren dat een <code class="classcolor">Huisdier</code> op zichzelf geen betekenis heeft,
         maar dat het enkel dient als basisklasse voor <code class="classcolor">Kat</code>, <code class="classcolor">Kip</code> of <code class="classcolor">Konijn</code>.
         In dat geval kan je overwegen de <mark>klasse als abstract</mark> te markeren:
      </p>
      <div class="codecompare top">
         <div class="precontainer">
            <pre><code>abstract class Huisdier {
   ...
}
</code></pre>
            <div class="codemarker" data-text="abstract" data-nth="2"></div>
         </div>
      </div>
      <p>
         Je <strong>moet</strong> het eerst overerven om te kunnen gebruiken:
      </p>
      <pre class="padtop" data-caption="Program.cs"><code>Huisdier h = new Huisdier(); // fout: Huisdier kan niet rechstreeks gebruikt worden
Kat minnie = new Kat(); // ok; afgeleide klasse Kat kan wel gebruikt worden
Konijn flappie = new Konijn(); // ok; afgeleide klasse Konijn kan wel gebruikt worden
</code></pre>
      <h3>Abstracte members</h3>
      <p>Je kan ook <mark>abstracte members</mark> maken: je kan ze dan niet direct gebruiken, maar ze <i>moeten</i> overschreven worden in elke afgeleide klasse:</p>
      <pre data-caption="Huisdier.cs"><code>abstract class Huisdier {
   ...
   public abstract string Info(); // geen implementatie want methode is abstract
}
</code></pre>
      <p>In de afgeleide klassen markeer je het weer met <code>override</code>, b.v in <code>Kip.cs</code>:</p>
      <div class="precontainer">
         <pre class="w-700" data-caption="Kip.cs"><code>class Kip : Huisdier {
   ...
   public override string Info() {
      return $@"Leeftijd: {Leeftijd}

{Bio}";
   }
   ...
}
</code></pre>
         <div class="codemarker" data-text="override"></div>
      </div>
      <ul class="arrow">
         <li>merk op dat je nu <code>base.Info()</code> niet meer kan gebruiken omdat basisklasse <code class="classcolor">Huisdier</code> geen implementatie heeft</li>
      </ul>
      <h2><code>is</code> en <code>as</code></h2>
      <p>Het voorbeeldprogramma herschreven, de oorspronkelijke versie rechts en de versie met overerving links:</p>
      <div class="codecompare">
         <div class="precontainer">
            <pre class="w-700" data-caption="Program.cs, met overerving"><code>class Program {
   static void Main(string[] args) {
      List&lt;Huisdier&gt; mijnHuisdieren = new List&lt;Huisdier&gt;();
      mijnHuisdieren.Add(new Kip() { Leeftijd = 0 });
      mijnHuisdieren.Add(new Kip() { Leeftijd = 5 });
      mijnHuisdieren.Add(new Kip(4, "Deze haan is erg schuw..."));
      mijnHuisdieren.Add(new Kat() { Leeftijd = 12, Naam = "Minou" });
      mijnHuisdieren.Add(new Kat(1, "Ik heb groene oge...", "Pistache" ));
      mijnHuisdieren.Add(new Konijn() { Leeftijd = 7, Naam = "Flappie" });
      mijnHuisdieren.Add(new Konijn(2, "Hoi ik ben Car...", "Caramel" ));

      // huisdieren
      foreach (Huisdier dier in mijnHuisdieren) {
         Console.WriteLine(dier); // ToString() methode
         Console.WriteLine(dier.Info());
         if (dier is Kip) {
            Kip kip = dier as Kip;
            Console.WriteLine($"De kip zegt: â{kip.Spreek()}â");
         }
         if (dier is Kat) {
            Kat kat = dier as Kat;
            Console.WriteLine($"{kat.Naam} zegt: â{kat.Spreek()}â");
         }
         if (dier is Konijn) {
            // doe niks; konijnen spreken niet
         }
         Console.WriteLine();
      }
      Console.ReadKey();
   }
}








</code></pre>
         <div class="codemarker" data-text="dier is Kat"></div>
         <div class="codemarker" data-text="dier is Konijn"></div>
         <div class="codemarker" data-text="dier is Kip"></div>
         <div class="codemarker" data-text="dier as Kat"></div>
         <div class="codemarker" data-text="dier as Konijn"></div>
         <div class="codemarker" data-text="dier as Kip"></div>
      </div>
      <pre class="w-700" data-caption="Program.cs, zonder overerving"><code>class Program {
   static void Main(string[] args) {
      List&lt;Kip&gt; mijnKippen = new List&lt;Kip&gt;();
      mijnKippen.Add(new Kip() { Leeftijd = 0 });
      mijnKippen.Add(new Kip() { Leeftijd = 5 });
      mijnKippen.Add(new Kip(4, "Deze haan is erg schuw..."));

      List&lt;Kat&gt; mijnKatten = new List&lt;Kat&gt;();
      mijnKatten.Add(new Kat() { Leeftijd = 12, Naam = "Minou" });
      mijnKatten.Add(new Kat(1, "Ik heb groene oge...", "Pistache"));

      List&lt;Konijn&gt; mijnKonijnen = new List&lt;Konijn&gt;();
      mijnKonijnen.Add(new Konijn() { Leeftijd = 7, Naam = "Flappie" });
      mijnKonijnen.Add(new Konijn(2, "Hoi ik ben Car...", "Caramel"));

      // kippen
      foreach (Kip kip in mijnKippen) {
         Console.WriteLine(kip); // ToString() methode
         Console.WriteLine(kip.Info());
         Console.WriteLine($"De kip zegt: â{kip.Spreek()}â");
         Console.WriteLine();
      }

      // katten
      foreach (Kat kat in mijnKatten) {
         Console.WriteLine(kat); // ToString() methode
         Console.WriteLine(kat.Info());
         Console.WriteLine($"{kat.Naam} zegt: â{kat.Spreek()}â");
         Console.WriteLine();
      }

      // konijnen
      foreach (Konijn konijn in mijnKonijnen) {
         Console.WriteLine(konijn); // ToString() methode
         Console.WriteLine(konijn.Info());
         // geen Spreek(); konijnen spreken niet
         Console.WriteLine();
      }
      Console.ReadKey();
   }
}
</code></pre>
</div>

      <ul class="arrow">
         <li>de code is nu <strong>korter</strong>, <strong>leesbaarder</strong> en <strong>intuÃ¯tiever</strong></li>
         <li>we hebben Ã©Ã©n lijst type <code class="classcolor">Huisdier</code> in plaats van drie aparte lijsten</li>
         <li>Het subtype van een object kun je controleren met <code>is</code>, naar een subtype casten kan met <code>as</code></li>
      </ul>
      <h2>Polymorfisme</h2>
      <p>
         Ter herinnering, er zijn drie implementaties van <code>Info()</code>: Ã©Ã©n algemene in de klasse
         <code class="classcolor">Huisdier</code> en twee specifieke in de klasse <code class="classcolor">Konijn</code> en <code class="classcolor">Kat</code>.
         Naar de buitenwereld toe is er echter slechts Ã©Ã©n methode <code>Info()</code>; de compiler zal
         automatisch de juiste versie oproepen naargelang de situatie (in dit geval het subtype)
      </p>
      <pre><code>foreach (Huisdier dier in mijnHuisdieren) {
   ...
   Console.WriteLine(dier.Info()); // Ã©Ã©n uitwendige methode, drie inwendige implementaties
   ...
}
</code></pre>
      <ul class="arrow">
         <li>
            Dit doet denken aan bv. method overloading: ook daar kan dezelfde methode dankzij meerdere inwendige implementaties gebruikt worden in verschillende versies (in dit geval naargelang de gebruikte parameters)
         </li>
         <li>
            Dit concept waarbij <strong>eenzelfde uitwendige vorm</strong> toch <strong>intern verschillende implementaties</strong> kan hebben, heet in de programmeerwereld <mark>polymorfisme</mark> (letterlijk: âmeerdere vormenâ)
         </li>
      </ul>
      <h2>Klassen hiÃ«rarchie</h2>
      <p>Je kan overerving verder doordrijven en ook <strong>sub-subclasses</strong> maken:</p>
      <p><img src="img/12_overerving/meer1.png" alt="" class="w-600"></p>
      <p>De volledige boomstructuur noemt men de <mark>klassen hiÃ«rarchie</mark>.</p>
      <p>Er zijn meerdere hiÃ«rarchieÃ«n te bedenken. Je kan b.v. een klasse <code class="classcolor">HuisdierMetNaam</code> maken enz... Alles hangt af van de complexiteit van de toepassing. In dit vak (tenzij anders vermeld) zal over het algemeen Ã©Ã©n overerving volstaan.</p>
      <div class="tips" data-caption="ð¡TE VEEL OF TE WEINIG KLASSEN">
         <p>
            De mogelijkheden zijn eindeloos; het ontwerp van de klassen hiÃ«rarchie is Ã©Ã©n van de belangrijkste taken van
            software engineering (samen met keuzes over properties, methoden, static of non-static, enumsâ¦). Over het
            algemeen geldt: hoe groter het project, hoe complexer de structuur.
         </p>
         <p>
            Welke keuzes je uiteindelijk maakt is kwestie van persoonlijke stijl en een kunst, maar over het algemeen
            geldt: <strong>te weinig structuur is niet goed, en teveel ook niet; het optimum ligt ergens âin het
               middenâ</strong>.
            Aan jou om door ervaring je eigen stijl te ontwikkelen.
         </p>
      </div>
      <h2>Pure klassen</h2>
      <p>
         Je zult misschien gemerkt hebben dat onze klassen <code class="classcolor">Huisdier</code>, <code class="classcolor">Kip</code>, <code class="classcolor">Kat</code> en <code class="classcolor">Konijn</code> puur zijn: nergens komt b.v. <code>Console.WriteLine()</code> voor. Dat betekent dat we onze klassen naadloos en onveranderd kunnen gebruiken in een heel andere omgeving, b.v. in een WPF toepassing:
      </p>
      <div class="codecompare top">
         <pre class="w-800 h-500" data-caption="test"><code>public partial class MainWindow : Window {
    public MainWindow() {
      InitializeComponent();
      // voorbeelden gebruik lege constructor met object initializer syntax
      lbxDieren.Items.Add(new Kip() { Leeftijd = 0 });
      lbxDieren.Items.Add(new Kip() { Leeftijd = 5 });
      lbxDieren.Items.Add(new Kat() { Leeftijd = 12, Naam = "Minou" });
      lbxDieren.Items.Add(new Konijn() { Leeftijd = 7, Naam = "Flappie" });

      // voorbeelden gebruik niet-lege constructor
      lbxDieren.Items.Add(new Kip(4, "Deze haan is erg schuw en duidelijk..."));
      lbxDieren.Items.Add(new Kat(1, "Ik heb groene ogen, daarom...", "Pistache"));
      lbxDieren.Items.Add(new Konijn(2, "Hoi ik ben Caramel en...", "Caramel"));
    }

    private void BtnTelDieren_Click(object sender, RoutedEventArgs e) {
      int aantalKatten = 0;
      int aantalKonijnen = 0;
      int aantalKippen = 0;
      foreach (Huisdier dier in lbxDieren.Items) {
         if (dier is Kat) aantalKatten++;
         else if (dier is Konijn) aantalKonijnen++;
         else if (dier is Kip) aantalKippen++;
         txtAantalDieren.Text = $"er zijn {aantalKatten} katten, {aantalKonijnen} konijnen en {aantalKippen} kippen";
      }
    }

    private void LbxDieren_SelectionChanged(object sender, SelectionChangedEventArgs e) {
      Huisdier dier = lbxDieren.SelectedItem as Huisdier;
      if (dier == null) return;
      txtDetails.Text = dier.Info();
      if (dier is Kat) {
         Kat kat = dier as Kat;
         txtDetails.Text += $"{Environment.NewLine}{kat.Naam} zegt: {kat.Spreek()}!";
      }
      if (dier is Kip) {
         Kip kip = dier as Kip;
         txtDetails.Text += $"{Environment.NewLine}De kip zegt: {kip.Spreek()}!";
      }
   }
}</code></pre>
         <img src="img/12_overerving/wpf.png" alt="" class="w-500">
      </div>
      <p>De gebruikte klassen zijn exact dezelfde gebleven.</p>
   </main>
   <footer>
      <img src="common/img/thats-all.jpg" alt="">
      <div class="footer__bottom">
         <p>@2024, Rogier van der Linde</p>
         <p>cursussen in dezelfde reeks: <a href="https://rogiervdl.github.io/HTML-course/">HTML</a> &mdash; <a href="https://rogiervdl.github.io/CSS-course/">CSS</a> &mdash; <a href="https://rogiervdl.github.io/JS-course/">Javascript</a> &mdash; <a href="https://rogiervdl.github.io/DEVENV-course/">Ontwikkelomgeving</a></p>
      </div>
   </footer>
   <a aria-label="up" id="up" href="#top"><span class="fas fa-chevron-circle-up"></span></a>
   <!-- scripts -->
   <script src="common/vendor/prism/prism.js"></script>
   <script src="common/vendor/hystmodal/hystmodal.min.js"></script>
   <script src="common/js/mode.js"></script>
   <script src="common/js/scripts.js"></script>
   <!-- Google tag (gtag.js) -->
   <script async src="https://www.googletagmanager.com/gtag/js?id=G-Q7JWZ9HHW0"></script>
   <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() { dataLayer.push(arguments); }
      gtag('js', new Date());

      gtag('config', 'G-Q7JWZ9HHW0');
   </script>
</body>

</html>
