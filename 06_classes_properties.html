<!DOCTYPE html>
<!-- [html-validate-disable no-trailing-whitespace] -->
<html lang="nl">

<head>
   <title>WPF layout | C# cheat sheets</title>
   <meta charset="UTF-8">
   <link rel="stylesheet" href="styles.css">
</head>

<body class="language-cs showpro">
   <div id="mode">
      <span>n00b</span>
      <label class="switch">
         <input type="checkbox" checked>
         <span class="slider round"></span>
      </label>
      <span>pro</span>
   </div>
   <nav class="site__nav">
      <a href="01_csharpsyntax.html" class="main__thumb" title="01. C# syntax">
         <p class="thumb__title">01. C# syntax</p>
         <img class="thumb__visual" src="img/01_csharpsyntax/icon.jpg" alt="">
      </a>
      <a href="02_dotnetclasses.html" class="main__thumb" title="02. .NET classes">
         <p class="thumb__title">02. .NET classes</p>
         <img class="thumb__visual" src="img/02_dotnetclasses/icon.png" alt="">
      </a>
      <a href="03_wpfcontrols.html" class="main__thumb" title="03. WPF controls">
         <p class="thumb__title">03. WPF controls</p>
         <img class="thumb__visual" src="img/03_wpfcontrols/icon.png" alt="">
      </a>
      <a href="04_wpflayout.html" class="main__thumb pro" title="04. WPF layout">
         <p class="thumb__title">04. WPF layout</p>
         <img class="thumb__visual" src="img/04_wpflayout/icon2.png" alt="">
      </a>
      <a href="05_bestanden.html" class="main__thumb pro">
         <p class="thumb__title">05. bestanden</p>
         <img class="thumb__visual" src="img/05_bestanden/icon.png" alt="">
      </a>
      <a href="06_classes_properties.html" class="main__thumb pro active">
         <p class="thumb__title">06. classes &amp; properties</p>
         <img class="thumb__visual" src="img/06_classes_properties/icon.jpg" alt="">
      </a>
      <a href="07_static_enum.html" class="main__thumb pro">
         <p class="thumb__title">07. static en enum</p>
         <img class="thumb__visual" src="img/07_static_enum/icon.jpg" alt="">
      </a>
      <a href="08_overerving.html" class="main__thumb pro">
         <p class="thumb__title">08. overerving</p>
         <img class="thumb__visual" src="img/08_overerving/icon.jpg" alt="">
      </a>
      <a href="09_sql_databanken.html" class="main__thumb pro">
         <p class="thumb__title">09. SQL databanken</p>
         <img class="thumb__visual" src="img/09_sql_databanken/icon.png" alt="">
      </a>   
   </nav>
   <h1>06. classes en properties</h1>
   <div id="toc"></div>
   <main>

      <!-- VIDEO -->
      <h2>On Youtube</h2>
      <h3>classes &amp; properties</h3>
      <div class="flexcontainer youtubecontainer">
         <iframe class="youtube" width="600" height="378" src="https://www.youtube.com/embed/sE48gsnO5KE" title="YouTube video player" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
         <figure class="print">
            <a href="https://www.youtube.com/watch?v=sE48gsnO5KE"><img src="img/06_classes_properties/youtube-ooad-classes.png" alt="" class="w-500"></a>
            <figcaption><a href="https://www.youtube.com/watch?v=sE48gsnO5KE">https://www.youtube.com/watch?v=sE48gsnO5KE</a></figcaption>
         </figure>
         <div class="youtube_toc">
            <ul>
               <li><a href="https://www.youtube.com/watch?v=sE48gsnO5KE">0:00 Intro</a></li>
               <li><a href="https://www.youtube.com/watch?v=sE48gsnO5KE?t=133">2:13 class maken</a></li>
               <li><a href="https://www.youtube.com/watch?v=sE48gsnO5KE?t=248">4:08 public vs. private variabelen</a></li>
               <li><a href="https://www.youtube.com/watch?v=sE48gsnO5KE?t=365">6:05 getter en setter methodes</a></li>
               <li><a href="https://www.youtube.com/watch?v=sE48gsnO5KE?t=660">11:00 underscore prefix van private variabelen</a></li>
               <li><a href="https://www.youtube.com/watch?v=sE48gsnO5KE?t=748">12:28 properties toevoegen</a></li>
               <li><a href="https://www.youtube.com/watch?v=sE48gsnO5KE?t=1079">17:59 automatische properties</a></li>
               <li><a href="https://www.youtube.com/watch?v=sE48gsnO5KE?t=1165">19:25 standaardwaarden</a></li>
               <li><a href="https://www.youtube.com/watch?v=sE48gsnO5KE?t=1250">20:50 constructors toevoegen</a></li>
               <li><a href="https://www.youtube.com/watch?v=sE48gsnO5KE?t=1722">28:42 :this()</a></li>
               <li><a href="https://www.youtube.com/watch?v=sE48gsnO5KE?t=1808">30:08 compositie van meerdere klassen</a></li>
               <li><a href="https://www.youtube.com/watch?v=sE48gsnO5KE?t=2016">33:36 methodes toevoegen</a></li>
               <li><a href="https://www.youtube.com/watch?v=sE48gsnO5KE?t=2350">39:10 gebruik van classes in hoofdprogramma</a></li>
            </ul>
         </div>
      </div>

      <h2>Class maken</h2>
      <p>
         Een <mark>class</mark> is een sjabloon (template) voor het aanmaken van nieuwe objecten. Stel dat we aan een project <strong>WpfBanking</strong> bezig zijn (met Console apps kan het ook); een nieuwe class voeg je toe via Add, New Item…
      </p>
      <div class="codecompare top">
         <img src="img/06_classes_properties/classmaken-1.png" alt="" class="w-500 bordered">
         <img src="img/06_classes_properties/classmaken-2.png" alt="" class="w-500 bordered">
      </div>
      <p>We hebben al een lege class met enkel een naam:</p>
      <pre><code>namespace WpfBanking {
   class Customer {
   }
}
</code></pre>
      <ul class="arrow">
         <li>we zullen de class nu inhoud geven</li>
      </ul>
      <p>Een <mark>class member</mark> (letterlijk vertaald: een <em>lid</em>) is een onderdeel van de class. De belangrijkste types zijn:</p>
      <ul>
         <li><span class="em">variabelen</span>: bevatten gegevens van een object</li>
         <li><span class="em">constructors</span>: beschrijven hoe objecten gemaakt worden</li>
         <li><span class="em">properties</span>: beschrijven de state (toestand) van een object</li>
         <li><span class="em">methodes</span>: beschrijven de behavior (gedrag) van een object</li>
      </ul>

      <h2>Variabelen</h2>
      <p>Laat ons enkele variabelen toevoegen:</p>
      <pre><code>class Customer
{
   int clientId; // bestaat uit exact 10 cijfers
   string firstName;
   string lastName;
   MailAddress email; // opmerking: class MailAddress zit in System.Net.Mail
   int rating = 3; // getal van 1 tot 5; standaardwaarde = 3
   DateTime birthDate; 
   DateTime registerDate;
}
</code></pre>
      <p>Je kan al instanties aanmaken met <code>new Customer()</code>, maar de variabelen aanspreken lukt blijkbaar nog niet:</p>
      <img src="img/06_classes_properties/variabelen1.png" alt="" class="bordered w-600">
      <p>
         De standaard zichtbaarheid voor members is <strong>private</strong>, d.w.z. enkel zichtbaar binnen het object zelf.
         <br>Je zou dit kunnen oplossen door de variabelen die je nodig hebt <strong>public</strong> te maken:
      </p>
      <pre class="wrong"><code>class Customer
{
   public int clientId; 
   public string firstName;
   public string lastName;
   public MailAddress email;
   public int rating = 3; 
   public DateTime birthDate; 
   private DateTime registerDate; // deze mag private blijven; is enkel voor intern gebruik
}
</code></pre>
      <p>De variabelen zijn nu wel toegankelijk:</p>
      <img src="img/06_classes_properties/variabelen2.png" alt="" class="bordered w-600">

      <p>
         Hoewel de public variabelen nu wel toegankelijk zijn, is dit een heel slechte programmeerstijl: maak <strong>nooit variabelen publiek</strong>, het is als de sleutels van je huis aan een vreemde geven!
      </p>
      <ul class="arrow">
         <li>maar hoe moet het dan wel…?</li>
         <li>we hebben <strong>properties</strong> nodig</li>
      </ul>

      <h2>Properties</h2>
      <p>
         Het idee is dat je <strong>variabelen altijd private</strong> houdt, en toegang geeft op een andere, gecontroleerde manier.
         Een eerste (slechte) oplossing is dat je voor elke variabele een <strong>get- en een set methode</strong> voorziet. Het nadeel is dat je meteen wel heel veel code hebt:
      </p>
      <div class="wrong">
         <pre class="h-500"><code>class Customer
{
   private int clientId; 
   private string firstName;
   private string lastName;
   private MailAddress email;
   private int rating = 3; 
   private DateTime birthDate;
   private DateTime registerDate;

   public int GetClientId() { // getter voor clienId
      return clientId;
   }
   public string GetFirstName() { // getter voor firstName
      return firstName;
   }
   public void SetFirstName(string fn) { // setter voor firstName
      firstName = fn;
   }
   public string GetLastName() { // getter voor lastName
      return lastName;
   }
   public void SetLastName(string ln) { // setter voor lastName
      lastName = ln;
   }
   public MailAddress GetEmail() { // getter voor email
      return email;
   }
   public void SetEmail(string em) { // setter voor email, met validatie
      try {
         MailAddress m = new MailAddress(em);
      } catch (FormatException) {
         throw new ArgumentException($"ongeldig email");
      }
      email = em;   
   }
   public int GetRating() { // getter voor rating
      return rating;
   }
   public void SetRating(int rtn) { // setter voor rating, met validatie
      if (rtn &lt; 1 || rtn &gt; 5) {
         throw new ArgumentOutOfRangeException($"rating moet tussen 1 en 5 liggen");
      }
      rating = rtn;
   }
   public DateTime GetBirthDate() { // getter voor birthDate
      return birthDate;
   }
   public void SetBirthDate(DateTime bd) { // setter voor birthDate
      birthDate = bd;
   }
}</code></pre>
      </div>
      <p>Daarom heeft men verkorte notaties bedacht, de zgn. <mark>properties</mark>. Dit fragment...</p>
      <pre><code>private string firstName;
...
public string GetFirstName() {
   return firstName;
}
public void SetFirstName(string fn) {
   firstName = fn;
}
</code></pre>
      <p>...wordt dan verkort tot een <mark>property</mark></p>
      <pre><code>private string firstName;
...         
public string FirstName { // naam begint met een hoofletter, en geen haakjes()
   get { return firstName; } // implementatie getter
   set { firstName = value; } // implementatie setter (met gereserveerd woord "value")
}    
</code></pre>
      <h3>automatische properties</h3>
      <p>Als je geen validatie nodig hebt, kan je het zelfs nóg korter schrijven tot een <mark>automatische property</mark>:</p>
      <pre><code>public string FirstName { get; set; } // automatische property</code></pre>
      <h3>read-only properties</h3>
      <p>Als je de setter weglaat, heb je een <strong>read-only property</strong>:</p>
      <pre><code>public string ClientId { get; } // read-only automatische property</code></pre>
      <h3>property standaardwaarde</h3>
      <p>Je kan <strong>standaardwaarden</strong> opgeven op deze manier:</p>
      <pre><code>public string Balance { get; set; } = 0; // automatische property met standaardwaarde</code></pre>
      <h3>volledig codevoorbeeld</h3>
      <p>De volledige code van de class tot nu toe is een stuk korter geworden:</p>
      <pre class="right"><code>class Customer {
   private string _email; // conventie: prefix property variabelen met _
   private int _rating = 3; // conventie: prefix property variabelen met _
   private DateTime registerDate;

   public int ClientId { get; } // automatische read-only property
   public string FirstName { get; set; } // automatische property
   public string LastName { get; set; } // automatische property
   public DateTime BirthDate { get; set; } // automatische property   
   public string Email { // niet-automatische property met validatie
      get { return _email; }
      set {
         try {
            MailAddress m = new MailAddress(value);
            _email = value;         
         } catch (FormatException) {
            throw new ArgumentException($"ongeldig email");
         }
      }
   }
   public int Rating { // niet-automatische property met validatie
      get { return _rating; }
      set {
         if (value &lt; 1 || value &gt; 5) {
            throw new ArgumentOutOfRangeException($"rating moet tussen 1 en 5 liggen");
         }
         _rating = value;
      }
   }
}
</code></pre>
      <p>De properties kunnen nu publiek gebruikt worden:</p>
      <img src="img/06_classes_properties/properties-publiek.png" alt="" class="bordered w-600">
      <p>Onze property validatie in actie:</p>
      <img src="img/06_classes_properties/properties-validatie.png" alt="" class="w-600">

      <h2>Constructors</h2>
      <p>
         Een <mark>constructor</mark> is een <strong>blauwdruk</strong> om een object te creëren.
      </p>
      <h3>lege constructor</h3>
      <p>
         Voor elke klasse bestaat, of je ‘m nu specifieert of niet, een <strong>lege constructor</strong>, d.i. de constructor zonder parameters:
      </p>
      <pre><code>class Customer {   
   // variabele(n)         
   private DateTime registerDate;

   // properties         
   public int ClientId { get; }
   public string FirstName { get; set; }
   public string LastName { get; set; }
   public DateTime BirthDate { get; set; }
   ...

   // lege constructor
   public Customer() { }
}</code></pre>
      <p>De variabelen en properties worden dan geïnitialiseerd op hun standaardwaarden:</p>
      <img src="img/06_classes_properties/properties-standaard.png" alt="" class="bordered w-600">
      <h3>aangepaste constructor</h3>
      <p>Je kan de constructor aanpassen om allerlei initialisaties te doen:</p>
      <pre><code>class Customer {
   // variabele(n)         
   private DateTime registerDate;

   // properties         
   public int ClientId { get; }
   public string FirstName { get; set; }
   public string LastName { get; set; }
   public int Rating { get; set; }    

   // aangepaste constructor
   public Customer() { 
      registerDate = DateTime.Now;
      FirstName = "John";
      LastName = "Doe";
      Rating = new Random().Next(1, 6); 
      ...
   }
}</code></pre>
      <p>Dit is trouwens exact wat we al die tijd in <code>MainWindow()</code> deden, de constructor van de <code class="classcolor">MainWindow</code> pagina:</p>
      <pre><code>public partial class MainWindow : Window {
   private DispatcherTimer timer;

   // MainWindow standaardconstructor
   public MainWindow() {
      InitializeComponent();
      sldAmount.Maximum = 100;
      sldAmount.Value = aantalEllipsen = 20;
      timer = new DispatcherTimer();
      timer.Interval = TimeSpan.FromMilliseconds(100);
      timer.Tick += SpawnEllipse;
   }
   ....
}   
</code></pre>
      <p>De variabelen en properties hebben nu beginwaarden meegekregen in de constructor:</p>
      <img src="img/06_classes_properties/properties-inits.png" alt="" class="bordered w-600">
      <p>Vaak kan je de constructor leeg te laten, en gewoon property standaardwaarden instellen:</p>
      <pre><code>class Customer {
   // variabele(n)         
   private DateTime registerDate = DateTime.Now;

   // properties         
   public int ClientId { get; }
   public string FirstName { get; set; } = "John";
   public string LastName { get; set; } = "Doe";
   public int Rating { get; set; } = new Random().Next(1, 6);    

   // standaardconstructor
   public Customer() { }
}
</code></pre>
      <h3>constructors met parameters</h3>
      <p>Je kan bijkomende constructors definiëren mét parameters:</p>
      <pre><code>// default constructor, zonder parameters
public Customer() {
   registerDate = DateTime.Now;
}

// constructor met parameters
public Customer(string fn, string ln) {
   registerDate = DateTime.Now;
   FirstName = fn;
   LastName = ln;
   Rating = (new Random()).Next(1, 6);
}

// constructor met parameters
public Customer(string fn, string ln, int rt) {
   registerDate = DateTime.Now;
   FirstName = fn;
   LastName = ln;
   Rating = rt;
}
</code></pre>
      <h3>constructor met <code>:this()</code></h3>
      <p>Je kan de vorige code nog inkorten door vanuit de ene constructor de andere op te roepen via <code>:this()</code></p>
      <img src="img/06_classes_properties/constructor-this.png" alt="" class="bordered w-600">
      <h4>constructor overloading</h4>
      <p>Het definiëren van meerdere constructoren met verschillende parameters heet <mark>constructor overloading</mark>. Je kan dan kiezen met welke constructor je een nieuw object aanmaakt:</p>
      <pre><code>Customer cust1 = new Customer(); // gebruik eerste constructor
Customer cust2 = new Customer("Bobby", "Peru"); // gebruik tweede constructor
Customer cust3 = new Customer("Johnny", "Miles", 4); // gebruik derde constructor
</code></pre>
      <h3>alternatief: object initialisatie</h3>
      <p>In plaats van alle mogelijke constructoren te definiëren voor alle mogelijke gevallen, kan je ook gewoon de lege constructor gebruiken met de <mark>object initialisatie</mark> syntax. Beide fragmenten zijn gelijkwaardig (al vind ik de tweede leesbaarder):</p>
      <div class="codecompare">
         <pre class="prism-vslight"><code>// klassieke notatie
Customer cust = new Customer(); 
cust.FirstName = "Johnny";
cust.LastName = "Miles";
cust.Rating = 4;
</code></pre>
         <pre class="prism-vslight right"><code>// object initializer syntax
Customer cust3 = new Customer() { 
   FirstName = "Johnny",
   LastName = "Miles",
   Rating = 4
}; 
</code></pre>
      </div>
      <h2>Methodes</h2>
      <p>Laat we onze klasse uitbreiden met methodes. Voegen we eerst nog een klasse <code class="classcolor">Account</code> toe...</p>
      <pre class="prism-vslight"><code>namespace WpfBanking {
   class Account {
      // properties
      public string AccountNr { get; set; }
      public Customer Holder { get; set; } // we gebruiken onze eigen Customer klasse
      public decimal Balance { get; set; } = 0; // tip: voor geldbedragen gebruiken we altijd decimal

      // constructor
      public Account(string nr) {
         AccountNr = nr;
      }
   }
}
</code></pre>
      <p>...en ook nog een klasse <code class="classcolor">Bank</code>, uitgebreid met enkele <strong>klasse methodes</strong>:</p>
      <pre class="prism-vslight"><code>namespace WpfBanking {
   class Bank {
      // properties
      public string Name { get; }
      public List&lt;Customer&gt; Customers { get; set; } = new List&lt;Customer&gt;(); // we gebruiken eigen Customer klasse
      public List&lt;Account&gt; Accounts { get; } = new List&lt;Account&gt;(); // we gebruiken eigen Account klasse

      // constructor
      public Bank(string name) {
         Name = name;
      }

      // klasse methodes
      public bool IsHealthy() {
         return CalculateGrandTotal() &gt; 0;
      }
      private decimal CalculateGrandTotal() {
         decimal total = 0;
         foreach (Account a in Accounts) {
            total += a.Balance;
         }
         return total;
      }
      public List&lt;A&gt;ccount&gt; GetAccountsLessThan(decimal amount) {
         List&lt;Account&gt; accounts = new List&lt;Account&gt;();
         foreach (Account a in Accounts) {
            if (a.Balance &lt; amount) accounts.Add(a);
         }
         return accounts;
      }
   }
}
</code></pre>
      <ul class="arrow">
         <li>denk goed na of je methode public (buiten de klasse beschikbaar) of private moet zijn</li>
         <li>denk na over parameters en returntype</li>
      </ul>
      <p>De nieuwe methodes (of toch de publieke) verschijnen eveneens in de intellisense: </p>
      <img src="img/06_classes_properties/methodes.png" alt="" class="bordered w-600">

      <h2>Best practices</h2>
      <h3>afspraken</h3>
      <p>
         Nog eens alle afspraken samengevat:
      </p>
      <ul class="arrow">
         <li><strong>variabelen</strong> zijn altijd <strong>private</strong></li>
         <li><strong>properties</strong> kunnen in principe ook private zijn, maar zijn meestal <strong>public</strong></li>
         <li><strong>properties</strong> beginnen met een <strong>hoofletter</strong>, <strong>variabelen</strong> met een <strong>kleine letter</strong></li>
         <li><strong>property variabelen</strong> beginnen met een <strong>underscore _</strong></li>
         <li>gebruik <strong>automatische properties</strong> als er geen validatie is</li>
      </ul>
      <div class="codecompare">
         <pre class="prism-vslight wrong"><code>private string _firstName;
...
public string FirstName 
{
   get { return _firstName; }
   set { _firstName = value; }
}    
</code></pre>
         <pre class="prism-vslight right"><code>...
public string FirstName 
{
   get;
   set;
}    </code></pre>
      </div>
      <h3>methode vs. property</h3>
      <p>Als een methode enkel een waarde teruggeeft, en dus eerder aanvoelt als een "eigenschap" van het object, gebruik je beter een <strong>read-only property</strong>:</p>
      <h3>constructor vs. object initializer</h3>
      <p>In plaats van allerlei constructors met parameters te definiëren, kan je vaak eenvoudig de lege constructor met de <strong>object initializer</strong> gebruiken:</p>
      <div class="codecompare">
         <div>
            <pre class="prism-vslight wrong"><code>// lege constructor
public Customer() { }

// extra constructors met parameters
public Customer(string fn, string ln) {
   registerDate = DateTime.Now;
   FirstName = fn;
   LastName = ln;
   Rating = (new Random()).Next(1, 6);
}
public Customer(string fn, string ln, int rt) : this(fn, ln) {
   Rating = rt;
}
</code></pre>
            <pre class="prism-vslight"><code>Customer cust1 = new Customer(); 
Customer cust2 = new Customer("Bobby", "Peru"); 
Customer cust3 = new Customer("Johnny", "Miles", 4); 
</code></pre>
         </div>
         <div>
            <pre class="prism-vslight right"><code>// lege constructor
public Customer() { }
</code></pre>
            <pre class="prism-vslight"><code>Customer cust1 = new Customer(); 
Customer cust2 = new Customer() { 
   FirstName = "Bobby",
   LastName = "Peru"
}; 
Customer cust3 = new Customer() { 
   FirstName = "Johnny",
   LastName = "Miles",
   Rating = 4
}; 
</code></pre>
         </div>
      </div>
      <h3>associatie / aggregatie / compositie</h3>
      <p>
         Als klassen met elkaar gerelateerd zijn ("<mark>associatie</mark>"), gebruik ze dan ook in elkaars definitie.
         Er zijn twee soorten: de <mark>compositie</mark> (A kan niet bestaan zonder B) en de <mark>aggregatie</mark> (A kan wel bestaan zonder B).
      </p>
      <img src="img/06_classes_properties/compositie.png" alt="" class="w-800">

      <h3>Gebruik klassen in een hoofdprogramma</h3>
      <p>Een voorbeeldgebruik van onze drie klassen <code class="classcolor">Bank</code>, <code class="classcolor">Account</code> en <code class="classcolor">Customer</code>:</p>
      <pre class="prism-vslight"><code>public partial class MainWindow : Window
{
   public MainWindow()
   {
      InitializeComponent();
      Bank jpmorgan = new Bank("JP Morgan");
      Customer kayne = new Customer("Kayne", "West");
      Customer kim = new Customer("Kim", "Kardashian");
      Account accountX = new Account("BE20001097");
      accountX.Holder = kim;
      jpmorgan.Customers.Add(kayne);
      jpmorgan.Customers.Add(kim);
      jpmorgan.Accounts.Add(accountX);
      if (jpmorgan.IsHealthy()) {
         // ...
      }
   }
}
</code></pre>
      <p>Merk op dat onze klasse verre van af zijn!</p>
      <ul class="wrong">
         <li>rekeningnummers blijven leeg</li>
         <li>als een account toegevoegd wordt aan een bank, worden de customers niet toegevoegd</li>
         <li>er is nog geen functionaliteit voor overschrijvingen, afhalingen, interesten...</li>
         <li>er zijn geen limieten op het saldo</li>
         <li>...</li>
      </ul>

      <h2>Klassen inspecteren in debugger</h2>
      <p>In debugger mode kun je doorklikken in de objectstructuur, bv. <strong>Bank → Accounts → Customers →</strong>...</p>
      <img src="img/06_classes_properties/debugger.png" alt="" class="w-600 bordered">

      
      
      
      









   </main>
   <a aria-label="up" id="up" href="#top"><span class="fas fa-chevron-circle-up"></span></a>
   <script src="vendor/prism.js"></script>
   <script src="js/mode.js"></script>
   <script src="js/scripts.js"></script>
   <!-- Google tag (gtag.js) -->
   <script async src="https://www.googletagmanager.com/gtag/js?id=G-Q7JWZ9HHW0"></script>
   <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() { dataLayer.push(arguments); }
      gtag('js', new Date());

      gtag('config', 'G-Q7JWZ9HHW0');
   </script>
</body>

</html>